---
title: Domain modeling
sidebar:
  order: 170
---

import { Aside, Tabs, TabItem } from '@astrojs/starlight/components';

Fluxzero allows you to model the state of your domain using entities that evolve over time by applying updates.
These entities — such as users, orders, etc. — maintain state and enforce invariants through controlled updates,
typically driven by commands.

---

## Defining the aggregate entity

To define a stateful domain object, annotate it with @Aggregate:

<Tabs>
  <TabItem label="Java">

```java
@Aggregate
@Builder(toBuilder = true)
public record UserAccount(@EntityId UserId userId,
                          UserProfile profile,
                          boolean accountClosed) {
}
```

  </TabItem>
  <TabItem label="Kotlin">

```kotlin
@Aggregate
@Builder(toBuilder = true)
data class UserAccount(
    @EntityId val userId: UserId,
    val profile: UserProfile,
    val accountClosed: Boolean
)
```

  </TabItem>
</Tabs>

This class models an aggregate with fields like `profile` and `accountClosed`.

An aggregate is a root entity that may contain nested child entities (via `@Member`) and acts as a unit of consistency.
Although an `@EntityId` is optional for aggregates, you’ll usually load them with `Fluxzero.loadAggregate(...)`.

<Aside type="tip">
Use strongly typed ID classes for better safety and traceability.
</Aside>

<Tabs>
  <TabItem label="Java">

```java
class UserId extends Id<UserAccount> {
    public UserId(String value) {
        super(value, "user-");
    }
}

@Aggregate
public record UserAccount(@EntityId UserId userId) {
}
```

```java
Entity<UserAccount> user = Fluxzero.loadAggregate(new UserId("1234"));
```

  </TabItem>
  <TabItem label="Kotlin">

```kotlin
class UserId(value: String) : Id<UserAccount>(value, "user-")

@Aggregate
data class UserAccount(@EntityId val userId: UserId)

val user = Fluxzero.loadAggregate(UserId("1234"))
```

  </TabItem>
</Tabs>

---

## Applying updates to entities

Updates typically originate from commands and evolve entities by applying validated changes.

Here’s an example of two commands — one to create a user and another to update their profile:

<Tabs>
  <TabItem label="Java">

```java
public record CreateUser(UserId userId,
                         UserProfile profile) {

    @AssertLegal
    void assertNotExists(UserAccount current) {
        throw new IllegalCommandException("Account already exists");
    }

    @Apply
    UserAccount apply() {
        return new UserAccount(userId, profile, false);
    }
}
```

```java
public record UpdateProfile(UserId userId,
                            UserProfile profile) {

    @AssertLegal
    void assertExists(@Nullable UserAccount current) {
        if (current == null) {
            throw new IllegalCommandException("Account not found");
        }
    }

    @AssertLegal
    void assertAccountNotClosed(UserAccount current) {
        if (current.isAccountClosed()) {
            throw new IllegalCommandException("Account is closed");
        }
    }

    @Apply
    UserAccount apply(UserAccount current) {
        return current.toBuilder().profile(profile).build();
    }
}
```

  </TabItem>
</Tabs>

<Aside type="note">
Handler method parameters like `UserAccount current` are injected automatically. Use `@Nullable` to indicate optional injection.
</Aside>

---

## Intercepting and transforming updates

Use @InterceptApply to modify or suppress updates *before* validation and application.

<Tabs>
  <TabItem label="Java">

```java
@InterceptApply
Object ignoreNoChange(UserAccount current) {
    if (current.getProfile().equals(profile)) {
        return null; // no-op
    }
    return this;
}
```

```java
@InterceptApply
UpdateProfile downgradeCommand(CreateUser command, UserAccount current) {
    return new UpdateProfile(command.getUserId(), command.getProfile());
}
```

```java
@InterceptApply
List<CreateTask> expandBulk(BulkCreateTasks bulk) {
    return bulk.getTasks();
}
```

  </TabItem>
</Tabs>

<Aside type="tip">
Flux recursively applies interceptors until no further transformation is needed.
</Aside>

---

## Invocation order

Update lifecycle steps:

1. Intercept using @InterceptApply
2. Assert preconditions using @AssertLegal
3. Apply state using @Apply

### Return types for interceptors:

| Return value                 | Effect                                 |
|-----------------------------|----------------------------------------|
| `null` or `void`            | Suppress update                        |
| `this`                      | No change                              |
| New update object           | Rewrite the update                     |
| Collection / Stream / Optional | Emit multiple updates              |

<Aside type="tip">
You can avoid storing unchanged updates by setting `eventPublication = IF_MODIFIED` on the aggregate or apply method.
</Aside>

---

## Summary

| Annotation        | Purpose                                        | Phase        |
|-------------------|------------------------------------------------|--------------|
| `@InterceptApply` | Rewrite, suppress, or expand updates           | Pre-check    |
| `@AssertLegal`    | Validate preconditions                         | Validation   |
| `@Apply`          | Apply state transformation                     | Execution    |

<Aside type="note">
  You may notice we don’t define a separate event class here (like <code>UserCreated</code>).
  In Fluxzero, the same payload often serves as both the command and the published event.

  This has a few advantages:
  - <strong>No duplication</strong>: you don’t maintain two almost-identical classes.
  - <strong>Accuracy</strong>: the event log stores exactly what was applied.
  - <strong>Less drift</strong>: command and event logic stay in sync.

  If you need to enrich or transform the event before publication, you can still do so in <code>@InterceptApply</code>.
</Aside>

---

## Why keep logic in the updates?

While it’s possible to implement domain logic in entities, it's usually best to keep validation and transformation logic inside update classes (typically commands).

**Advantages of update-based logic:**

- Each update owns its behavior
- Entities remain focused on holding state
- Features are easier to isolate and remove
- Tests are simpler and more targeted

---

## Alternative: logic in the entity

It’s possible to put validation and logic inside the aggregate itself — but this often leads to bloat:

<Tabs>
  <TabItem label="Java">

```java
@Aggregate
@Builder(toBuilder = true)
public record UserAccount(@EntityId UserId userId,
                          UserProfile profile,
                          boolean accountClosed) {

    @AssertLegal
    static void assertNotExists(CreateUser update, @Nullable UserAccount user) {
        if (user != null) {
            throw new IllegalCommandException("Account already exists");
        }
    }

    @Apply
    static UserAccount create(CreateUser update) {
        return new UserAccount(update.getUserId(), update.getProfile(), false);
    }

    @AssertLegal
    static void assertExists(UpdateProfile update, @Nullable UserAccount user) {
        if (user == null) {
            throw new IllegalCommandException("Account does not exist");
        }
    }

    @AssertLegal
    void assertAccountNotClosed(UpdateProfile update) {
        if (accountClosed) {
            throw new IllegalCommandException("Account is closed");
        }
    }

    @Apply
    UserAccount update(UpdateProfile update) {
        return toBuilder().profile(update.getProfile()).build();
    }
}
```

  </TabItem>
</Tabs>

<Aside type="caution">
Embedding all behavior into the aggregate increases coupling and reduces testability. Avoid unless needed.
</Aside>

---

## Mixing strategies

Fluxzero supports mixing both styles:

- Use @AssertLegal on the update (command)
- Use @Apply on the entity
- Or vice versa

That said, keeping logic in the update tends to result in simpler, more testable, and easier-to-maintain code.