---
title: Introduction
description: Fluxzero is a cloud runtime that lets you focus on business logic instead of infrastructure.
sidebar:
    order: 10
---

import {Aside} from '@astrojs/starlight/components';

Most developers don’t struggle because their product is complex — they struggle because everything around it is.
Before you can even start, you’re knee-deep in infrastructure, boilerplate, and ceremony that has nothing to do with your idea.

Fluxzero was born out of that frustration. We wanted a way to write only the logic that drives a product, without drowning in the scaffolding around it. After years of pushing technology to serve that goal, we built the platform we wished existed from the start.

---

## What is Fluxzero?

Fluxzero is a cloud runtime for building backends without infrastructure overhead.

It’s designed to help you move fast by writing only your product’s business logic — no boilerplate or distractions. Whether you’re building an MVP or aiming for planet-scale, Fluxzero gives you a clean, consistent way to express your ideas in code.

Instead of gluing together tools, layering service code, mapping models, and wiring up infrastructure, **you just write messages and handlers**. Fluxzero takes care of everything else: delivery, routing, persistence, retries, observability, and scale.

Whether you’re running a single instance or hundreds of distributed services, your code stays the same — no rewrites, no migrations. Just expressive business logic that scales from day one.

<Aside type="note">
    Fluxzero handles the heavy lifting so you can focus on your product. You build 10× faster with 10× less code.
</Aside>

---

## Why we built it

Fluxzero exists because backend development was stuck in a loop.
Every project started with the same plumbing: infrastructure setup, service wiring, layers of boilerplate. None of it was product logic — but it consumed most of the time.

We wanted a different foundation. Not another framework, but a **runtime**: a complete environment where code and infrastructure are inseparable, and business logic is the only thing you write.

Fluxzero flips the model. You focus entirely on messages and handlers, while the runtime takes care of everything around them — messaging, persistence, scheduling, observability, deployment. No scaffolding, no rewrites.

These capabilities aren’t bolted on. They’re part of the core design, refined over years to deliver the performance, security, and observability that production demands.

<Aside type="note">
    Fluxzero isn’t a workaround. It’s a runtime built to make clean, expressive code the default.
</Aside>


---

## Designed for clean code

Fluxzero offers a simpler, more natural way to write backend code.

You model your domain with messages — like commands and queries — and implement side effects with simple handlers. That’s it.

- **No boilerplate** — no wiring, annotation soup, or framework acrobatics
- **No local dependencies** — no databases, queues, or containers required
- **Automatic concurrency**: No thread management, connection pools, or async/await complexity
- **Built-in backpressure**: System automatically handles load without manual throttling or circuit breakers
- **Fully testable** — test entire business flows using given–when–then patterns
- **Scales with you** — the code you write on day one is the same code that runs at scale

Fluxzero was designed so you can write scalable business applications with zero scaffolding — just clear, expressive logic.

### Sample feature

import {Tabs, TabItem} from '@astrojs/starlight/components';

<Tabs>
  <TabItem label="Java">
    ```java
    public record RenameDocument(DocumentId documentId, @NotBlank String newTitle) {
        @Apply
        Document rename(Document document) {
            return document.withTitle(newTitle);
        }
    }
    ```
  </TabItem>
  <TabItem label="Kotlin">
    ```kotlin
    data class RenameDocument(val documentId: DocumentId, @field:NotBlank val newTitle: String) {
        @Apply
        fun rename(document: Document): Document {
            return document.copy(title = newTitle)
        }
    }
    ```
  </TabItem>
</Tabs>

Now compare this to traditional backend development, where even a tiny update like this often means:

- Writing a service layer with dependency injection
- Building a repository with SQL queries or ORM mappings
- Managing database connections and transactions
- Handling request/response serialization and validation
- Adding error handling, concurrency safeguards, and routing logic

With Fluxzero, you don’t need any of that.

You just write the business logic — clean, expressive, and testable.
Everything else — delivery, persistence, retries, routing, metrics, and auditing — is built in.

---

## Zero ops deployment

Fluxzero doesn’t just help you write better code — it takes the pain out of getting that code into production.

With Fluxzero Cloud, you can go from local dev to full production with a single push — no infra setup, no config files, no ops overhead.

- **Push-to-deploy simplicity** — Use a GitHub Action or API call to deploy. If your cluster or app doesn’t exist yet, it’s created on the fly.
- **No infra to configure** — Clusters, load balancers, storage, messaging, and scaling are provisioned automatically.
- **Reproducible environments** — Define your apps and clusters once, then deploy them anywhere.
- **Self-host or Cloud** — Run on Fluxzero Cloud or bring your own infrastructure — your code doesn’t change.

<Aside type="note">
 From laptop to production in minutes. No YAML. No Terraform. No cloud console. Just your existing code.
</Aside>

---

## Core advantages

- **Blazing Velocity** – Build complete backends in hours, not months — fewer moving parts, less boilerplate, less code.
- **Same Code, All the Way Up** – The code you write on day 1 is still right on day 1000. No rewrites, no migrations, no architectural U-turns.
- **Clean Code by Default** – Your logic lives inside messages. No layers, no glue code — just POJOs, handlers, and clear intent.
- **Effortless Testing** – Test full business flows with given–when–then patterns. No mocks. No containers. Just logic.
- **Scales Hard. Observes Everything. Exposes Nothing.** – Millions/sec throughput, full auditability, built-in backpressure, and zero exposed attack surface.
- **Integrated by Design** – HTTP, messaging, scheduling, search, event sourcing, auditing, access control — all in one runtime.
- **Zero Ops Deployment** – Deploy to Fluxzero Cloud with a single GitHub Action or API call. No infrastructure to manage, no configuration required.

---

## Why this matters for productivity

Fluxzero transforms how you build.

By removing layers of boilerplate and technical ceremony, it clears the path for teams to focus entirely on product logic. The result is a faster, cleaner, more enjoyable development process — one where features flow instead of stall.

### What changes

This changes how teams work:

- **Less Wiring, More Shipping** — Spend your time building product features, not plumbing infrastructure.
- **Fewer Bugs, Clearer Code** — With less indirection and fewer moving parts, your domain logic stays obvious and correct.
- **Better Traceability** — Understand how a feature works — or why something broke — just by following the messages.
- **Faster Onboarding** — New developers can grasp the full system in days, not weeks.
- **Deploy With Confidence** — Entire business flows can be tested end-to-end. No mocks. No gaps. No surprises in production.
- **Less Process** — Teams work on isolated features without stepping on each other’s toes, requiring less process overhead.


<Aside type="note">
    Fluxzero shortens the path from idea to feature — and makes your team faster, calmer, and more effective.
</Aside>

### Works well with AI

Fluxzero’s design makes it easy for LLMs to generate code that actually works.

- **Natural Code Generation** – Because Fluxzero enables clean business code, LLMs can generate real features — not just snippets.
- **Less Configuration** – Fewer files, fewer settings, and fewer places to go wrong.
- **Consistent Structure** – Every feature follows the same clean pattern — easy to generate, understand, and evolve.

<Aside type="note">
 Fluxzero pairs naturally with LLMs — making AI a real coding partner, not just a copy-paste tool.
</Aside>

---

## Who it's for

Fluxzero is for anyone building business backend software — without wanting to drown in boilerplate, frameworks, and infrastructure.

Whether you're a solo dev or part of a large team, Fluxzero helps you stay focused on what matters: your product.

It’s especially well suited for:

- **Startup teams** – Ship fast without duct-taping 12 tools together. Go from MVP to scale with no architectural rewrites.
- **Product engineers** – Write only the logic that moves the product forward. No glue code, no framework fights.
- **Architects** – Enforce structure and separation by default — without adding layers.
- **Platform teams** – Provide powerful backend capabilities to other teams, while reducing maintenance burden.
- **AI-assisted developers** – Generate real, working features — not boilerplate scaffolding or mock stubs.
- **Modern Java/Kotlin shops** – Leverage your existing skills and ecosystem — but with far less code.

<Aside type="note">
    Whether you’re building something small or massive — if your product has business logic, Fluxzero is for you.
</Aside>

<Aside type="tip">
    Excited or doubtful? [Try building your first app](/docs/tutorials/first-app).
</Aside>
