---
title: Introduction
description: Fluxzero is a developer productivity platform that lets you focus on business logic instead of infrastructure.
sidebar:
   order: 10
---

import { Aside } from '@astrojs/starlight/components';
import { Image } from 'astro:assets';
import { YouTube } from '@astro-community/astro-embed-youtube';
import simpleArchitecture from '~/assets/architecture/simplified.png';


# What is Fluxzero?

Fluxzero is a backend development platform that handles infrastructure so you can focus on business logic. Instead of configuring databases, message queues, and HTTP routing, you write message handlers.

> **You write the business code. Fluxzero handles the plumbing.**

### See Fluxzero in action

<YouTube />

---

## Our mission

Building software today means stitching together countless tools and frameworks: identity management, APIs, auditing, search, scalability, and security. Most of your time ends up spent on infrastructure—not the product.

**Fluxzero flips that around.**

It gives you a clean, scalable foundation for software development, with everything you need to ship business applications out of the box:

- **Scalable by default** – No setup required to scale your workloads.
- **Secure by default** – Your applications are never exposed directly to the internet.
- **Complete toolkit** – Built-in support for HTTP, job scheduling, full-text search, auditing, and more.
- **Java-based** – Use the libraries, tools, and ecosystem you already know.
- **Open source** – Self-host it or use our fully managed service.


Basically, we want you to focus on building your product, not the infrastructure. Fluxzero is designed to handle the heavy lifting so you can ship features faster and with less hassle.

- Everything is extremely testable without the need for mocking or stubbing
- No dependencies on complicated infrastructure
- For development, you only need Java (no databases, no message brokers, no caching layers)

---

## Why this matters for productivity

Most backend development time goes to infrastructure setup, configuration, and debugging distributed systems. Fluxzero removes most of this overhead.

### What changes

- **No infrastructure code**: No HTTP routing, database connections, message queue setup, or service configuration
- **Pure business logic**: Message handlers contain only your domain logic—no framework boilerplate
- **Automatic concurrency**: No thread management, connection pools, or async/await complexity
- **Built-in backpressure**: System automatically handles load without manual throttling or circuit breakers
- **HTTP request visibility**: All inbound and outbound HTTP requests are handled as messages, providing full observability
- **Testing**: Test message handlers like pure functions—no mocking databases or HTTP clients
- **One programming model**: HTTP requests, background jobs, webhooks, and scheduling all use the same message handlers

### Works well with AI

AI coding assistants are more effective with Fluxzero because:

- **Simpler patterns**: Three message types (command/query/event) instead of dozens of frameworks and plumbing code
- **Less configuration**: Fewer files and settings that can be wrong
- **Consistent structure**: Every feature follows the same pattern

import { Tabs, TabItem } from '@astrojs/starlight/components';

<Tabs>
<TabItem label="Java">
```java
@HandleCommand
public Device addDevice(AddDevice command) {
    // Just business logic - no HTTP routing, validation annotations, or response handling
    return new Device(command.homeId(), command.deviceType(), command.name());
}
```
</TabItem>
<TabItem label="Kotlin">
```kotlin
@HandleCommand
fun addDevice(command: AddDevice): Device {
    // Just business logic - no HTTP routing, validation annotations, or response handling
    return Device(command.homeId, command.deviceType, command.name)
}
```
</TabItem>
</Tabs>

Compare this to traditional development where you'd need:
- REST controller with routing annotations
- Service layer with dependency injection
- Repository with SQL queries or ORM mapping
- Database connection management
- Request/response serialization
- Error handling and validation
- Transaction management

Fluxzero handles all of that infrastructure automatically. You just write the business logic.

---

## Who it's for

Fluxzero works well for:

- Teams building internal tools or APIs without dedicated infrastructure staff
- Developers who spend too much time on setup and configuration
- Projects where you want to focus on business logic rather than distributed systems
- Codebases that work with AI coding assistants

If you find yourself spending weeks setting up infrastructure before writing your first business feature, Fluxzero might be a good fit.

<Aside type="tip">
Skeptical? [Try it out yourself](/about/get-started).
</Aside>

---

## Fluxzero components

In the diagram below, you can see the main components of a Fluxzero application and how they interact with each other.

<Image src={simpleArchitecture} alt="Architecture diagram" class={"dark:bg-white"}  style={"background-color: var(--sl-color-gray-4);"}/>


- **Centralized orchestration via the Fluxzero Server**  
  The server is the brain of the system: it handles message routing, storage, indexing for search, scheduling, and autoscaling.

- **No direct HTTP exposure**  
  Applications don’t expose HTTP endpoints themselves. All external traffic flows through the **Fluxzero Proxy**, which handles authentication, rate limiting, and routing.

- **External HTTP integration via proxy**  
  Outgoing calls to third-party APIs also pass through the proxy.  
  [Why this is a good idea →](../concepts/proxy-routing)


- **Persistent WebSocket connections**  
  Fluxzero clients connect to the server via WebSockets, enabling real-time bi-directional communication at scale.


## Message-driven development

Fluxzero applications use three types of messages:

- **Commands** → Make something happen (`CreateOrder`, `UpdateUser`)
- **Queries** → Get data (`GetOrderHistory`, `FindUsers`)  
- **Events** → Something happened (`OrderCreated`, `UserRegistered`)

Every feature you build follows this pattern. Instead of learning different frameworks for HTTP routing, background jobs, webhooks, and event handling, you write message handlers.

For example, to send a welcome email when someone registers:

```java
@HandleEvent
public void sendWelcomeEmail(UserRegistered event) {
    emailService.send(event.userEmail(), "Welcome!");
}
```

This approach keeps code predictable and reduces the variety of patterns you need to remember.

---

## Comparison with traditional stacks

| Task | Traditional approach | With Fluxzero |
|------|---------------------|---------------|
| **New project setup** | Configure databases, message queues, HTTP framework | Run one command, start coding |
| **Add API endpoint** | Route, controller, validation, serialization | Write message handler |
| **Background job** | Set up job queue, workers | Handle command or event |
| **Full-text search** | Integrate search engine | Built-in, works automatically |
| **Testing** | Mock databases, HTTP clients, queues | Test pure functions |
| **Audit trail** | Custom logging implementation | Automatic for all messages |

The main difference is that Fluxzero provides infrastructure as a service, so you spend more time on application code.

## Server requirements 

- Java 21 or higher
- PostgreSQL 15 or higher

---

<Aside type="tip">
Fluxzero is open source. [Explore the code on GitHub](https://github.com/fluxzero-io/flux-capacitor-client), or get started with our managed service in minutes.
</Aside>