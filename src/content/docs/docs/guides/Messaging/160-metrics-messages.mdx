---
title: Metrics messages
sidebar:
  order: 160
---

import { Tabs, TabItem, Aside } from '@astrojs/starlight/components';

Fluxzero supports a built-in message type for metrics: `MessageType.METRICS`.

These messages provide a powerful way to observe and trace system behavior across clients, handlers, and infrastructure.

Metrics messages are:

- Lightweight, structured, and traceable
- Logged like any other message
- Routable to handlers (via @HandleMetrics)
- Stored by default for **1 month** due to volume

---

## Publishing metrics

You can publish metrics manually using `Fluxzero.publishMetrics(...)`:

<Tabs>
  <TabItem label="Java">

```java
Fluxzero.publishMetrics(new SystemMetrics("slowProjection", "thresholdExceeded"));
```

  </TabItem>
  <TabItem label="Kotlin">

```kotlin
Fluxzero.publishMetrics(SystemMetrics("slowProjection", "thresholdExceeded"))
```

  </TabItem>
</Tabs>

This emits a structured metrics message to the metrics topic.

All metrics are wrapped in a regular `Message`, so you can include metadata or delivery guarantees:

<Tabs>
  <TabItem label="Java">

```java
Fluxzero.get()
    .metricsGateway()
    .publish(new MyMetric("foo"),
             Metadata.of("critical", "true"),
             Guarantee.STORED);
```

  </TabItem>
  <TabItem label="Kotlin">

```kotlin
Fluxzero.get()
    .metricsGateway()
    .publish(MyMetric("foo"),
             Metadata.of("critical", "true"),
             Guarantee.STORED)
```

  </TabItem>
</Tabs>

---

## Automatic metrics from clients

Many metrics are emitted automatically by the Flux Java client:

- Connect/disconnect events when clients start or stop
- Tracking stats (throughput, latency, handler timing)
- Search, state, or document store usage
- Web request round-trip timings

<Aside type="note">
These built-in metrics help diagnose issues and improve observability with minimal effort.
</Aside>

---

## Consuming metrics

You can handle metrics just like other message types:

<Tabs>
  <TabItem label="Java">

```java
@HandleMetrics
void on(MetricEvent event) {
    log.debug("Observed metric: {}", event);
}
```

  </TabItem>
  <TabItem label="Kotlin">

```kotlin
@HandleMetrics
fun on(event: MetricEvent) {
    log.debug("Observed metric: {}", event)
}
```

  </TabItem>
</Tabs>

Use this to feed dashboards, update counters, or trigger alerts.

---

## Disabling metrics

To reduce noise or overhead, you can disable automatic metric publishing:

### Option 1: Disable via handler or batch interceptors

<Tabs>
  <TabItem label="Java">

```java
@Consumer(handlerInterceptors = DisableMetrics.class)
public class SilentHandler {
    @HandleEvent
    void on(MyEvent event) {
        // ...
    }
}
```

  </TabItem>
  <TabItem label="Kotlin">

```kotlin
@Consumer(handlerInterceptors = [DisableMetrics::class])
class SilentHandler {

    @HandleEvent
    fun on(event: MyEvent) {
        // ...
    }
}
```

  </TabItem>
</Tabs>

You can also disable metrics for an entire consumer by using `batchInterceptors`.

### Option 2: Disable globally in the client config

When creating a WebSocket client, set `disableMetrics = true` in the configuration.

### Option 3: Disable dynamically using a dispatch interceptor

<Tabs>
  <TabItem label="Java">

```java
AdhocDispatchInterceptor.runWithAdhocInterceptor(() -> {
    // your code here
}, (message, messageType, topic) -> null, MessageType.METRICS);
```

  </TabItem>
  <TabItem label="Kotlin">

```kotlin
AdhocDispatchInterceptor.runWithAdhocInterceptor(
    { /* your code here */ },
    { _, _, _ -> null },
    MessageType.METRICS
)
```

  </TabItem>
</Tabs>

<Aside type="tip">
This is useful if you want to temporarily suppress metric logging within a specific code block.
</Aside>

---

## Common use cases

- **Audit debugging**: trace which handler caused a slowdown
- **Observability**: track search throughput or handler lag
- **Dashboards**: surface per-entity or per-consumer stats
- **Alerting**: trigger alerts on retries, delays, or timeouts

<Aside type="note">
Metrics messages offer low-overhead insight into runtime behaviorâ€”use them to light up your observability stack.
</Aside>