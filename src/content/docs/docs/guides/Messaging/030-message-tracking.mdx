---
title: Message tracking
description: Message tracking
sidebar:
  order: 30
---

import { Tabs, TabItem } from '@astrojs/starlight/components';

Fluxzero handles message dispatch asynchronously by default. When a message such as a command is published:

1. It is sent to the Fluxzero Runtime.
2. The Runtime logs the message and notifies all subscribed consumers.
3. Consumers stream these messages to the relevant handler methods.

## Default Consumer Behavior

By default, handlers join the **default consumer** for a given message type. For example:

<Tabs>
<TabItem value="Java" label="Java">

```java
class MyHandler {
    @HandleCommand
    void handle(SomeCommand command) {
        // business logic here
    }
}
```

</TabItem>
<TabItem value="Kotlin" label="Kotlin">

```kotlin
class MyHandler {
    @HandleCommand
    fun handle(command: SomeCommand) {
        // business logic here
    }
}
```

</TabItem>
</Tabs>

This handler joins the default **command consumer** automatically.

## Custom Consumers with @Consumer

You can override the default behavior using the `@Consumer` annotation:

<Tabs>
<TabItem value="Java" label="Java">

```java
@Consumer(name = "MyConsumer")
class MyHandler {
    @HandleCommand
    void handle(SomeCommand command) {
        // business logic
    }
}
```

</TabItem>
<TabItem value="Kotlin" label="Kotlin">

```kotlin
@Consumer(name = "MyConsumer")
class MyHandler {
    @HandleCommand
    fun handle(command: SomeCommand) {
        // business logic
    }
}
```

</TabItem>
</Tabs>

To apply this to an entire package (and its subpackages), add a `package-info.java` file:

```java
@Consumer(name = "MyConsumer")
package com.example.handlers;
```

## Customizing consumer configuration

You can tune the behavior using additional attributes on the `@Consumer` annotation:

<Tabs>
<TabItem value="Java" label="Java">

```java
@Consumer(name = "MyConsumer", threads = 2, maxFetchSize = 100)
class MyHandler {
    @HandleCommand
    void handle(SomeCommand command) {
        // business logic
    }
}
```

</TabItem>
<TabItem value="Kotlin" label="Kotlin">

```kotlin
@Consumer(name = "MyConsumer", threads = 2, maxFetchSize = 100)
class MyHandler {
    @HandleCommand
    fun handle(command: SomeCommand) {
        // business logic
    }
}
```

</TabItem>
</Tabs>

- `threads = 2`: Two threads per application instance will fetch commands.
- `maxFetchSize = 100`: Up to 100 messages fetched per request, helping apply backpressure.

Each thread runs a **tracker**. If you deploy the app multiple times, Fluxzero automatically load-balances messages across all available trackers.

## Default consumer settings

Fluxzero provides conservative defaults to ensure safe and sequential processing:

| Setting                | Description | Default value             |
|------------------------|-------------|---------------------------|
| `threads`              | Number of tracker threads. Each thread owns a disjoint segment of the log. | `1`                       |
| `maxFetchSize`         | Maximum messages per batch; balances throughput and memory. | `1024`                    |
| `maxWaitDuration`      | How long to wait before polling again if no messages are available. | `60`                      |
| `durationUnit`         | Time unit for `maxWaitDuration`. | `SECONDS`                 |
| `errorHandler`         | Logs processing errors and continues. | `LoggingErrorHandler`     |
| `flowRegulator`        | Default backpressure strategy; no throttling. | `NoOpFlowRegulator`       |
| `filterMessageTarget`  | If true, only messages targeted to this instance are processed. | `false`                   |
| `ignoreSegment`        | If true, bypasses Runtime sharding and processes all segments. | `false`                   |
| `singleTracker`        | If true, a single tracker processes all messages in strict global order. | `false`                   |
| `clientControlledIndex`| If true, the app decides which messages to process. | `false`                   |
| `storePositionManually`| If true, the app must commit tracker position explicitly. | `false`                   |
| `exclusive`            | Handlers are active in only one consumer. | `true`                    |
| `passive`              | If true, handler results are ignored and not published to the result log. | `false`                   |
| `minIndex`             | Negative means start at the end of the log (only new messages). | `-1`                      |
| `maxIndexExclusive`    | Negative means no upper bound. | `-1`                      |
| `typeFilter`           | No server-side filtering; all message types are delivered. | `""` (empty)              |

## Custom routing keys

By default, Fluxzero uses **128 segments** to balance parallelism and ordering guarantees. These segments are evenly split across available trackers to distribute load efficiently. The `ignoreSegment` configuration, when set to `true`, means that each tracker receives all messages regardless of segment assignment. This allows filtering and routing to be applied at the client or handler level using custom routing keys rather than relying on segment-based filtering. The `singleTracker` option can be enabled to force all segments to be managed by a single tracker instance, simplifying ordering at the cost of scalability.

To enable client-side filtering using a custom routing key, annotate your handler class with `@Consumer(name = "...", ignoreSegment = true)`. Then, use the `@RoutingKey` annotation on your handler method (or class) to specify which field to use for routing.

<Tabs>
  <TabItem value="java" label="Java">

```java
@Consumer(name = "order-processor", ignoreSegment = true)
class OrderProcessor {
    @HandleCommand
    @RoutingKey("paymentId")
    void handle(SubmitOrder command) {
        // Handler logic here, routing messages by paymentId instead of segment
    }
}
```

  </TabItem>
  <TabItem value="kotlin" label="Kotlin">

```kotlin
@Consumer(name = "order-processor", ignoreSegment = true)
class OrderProcessor {
    @HandleCommand
    @RoutingKey("paymentId")
    fun handle(command: SubmitOrder) {
        // Handler logic here, routing messages by paymentId instead of segment
    }
}
```

  </TabItem>
</Tabs>