---
export interface Props {
  slug: string;
  rootSelector?: string;
  mountId?: string;
  isFeedbackEnabled: boolean;
}

const {
  slug,
  rootSelector = "",
  mountId = "",
  isFeedbackEnabled = true,
} = Astro.props;
---

<script type="module" define:vars={{ rootSelector, mountId, isFeedbackEnabled }}>
  import {
    getState,
    submitFeedback,
  } from "/src/components/feedback/feedbackStore.ts";
  import { buildSegmentsFromRange } from "/src/components/feedback/domAnchors.ts";
  if (isFeedbackEnabled) {
    class SelectionPromptController {
      constructor(rootSelector, mountId) {
        this.el = null;
        this.tempHighlight = null;
        this.lastRange = null;
        this.lastText = "";
        this.rootSelector = rootSelector;
        this.mountId = mountId;
        this.root = null;
        this.handleSelectionChange = this.handleSelectionChange.bind(this);
        this.handleScrollOrResize = this.handleScrollOrResize.bind(this);
        this.onPromptClick = this.onPromptClick.bind(this);
        this.init();
      }

      init() {
        this.root = this.resolveRoot(this.rootSelector);
        document.addEventListener("mouseup", this.handleSelectionChange);
        document.addEventListener("keyup", this.handleSelectionChange);
        document.addEventListener("touchend", this.handleSelectionChange, {
          passive: true,
        });
        window.addEventListener("scroll", this.handleScrollOrResize, {
          passive: true,
        });
        window.addEventListener("resize", this.handleScrollOrResize, {
          passive: true,
        });
      }

      resolveRoot(selector) {
        if (selector) {
          const el = document.querySelector(selector);
          if (el && el instanceof HTMLElement) return el;
        }
        if (this.mountId) {
          const mount = document.getElementById(this.mountId);
          if (mount && mount.parentElement instanceof HTMLElement)
            return mount.parentElement;
        }
        // Prefer the main content element if present, otherwise fallback to body
        const main = document.querySelector("main");
        return main instanceof HTMLElement ? main : document.body;
      }

      ensureEl() {
        if (this.el) return this.el;
        const el = document.createElement("div");
        el.className = "feedback-selection-prompt";
        el.innerHTML = `ðŸ’¬ <span>Add a comment</span>`;
        el.style.position = "fixed";
        el.style.zIndex = "2000";
        el.style.display = "none";
        document.body.appendChild(el);
        this.el = el;
        this.el.addEventListener("click", this.onPromptClick);
        return el;
      }

      handleScrollOrResize() {
        if (this.el && this.el.style.display !== "none") {
          const sel = window.getSelection();
          if (sel && sel.rangeCount > 0 && !sel.isCollapsed) {
            const range = sel.getRangeAt(0);
            this.position(range);
          } else {
            this.hide();
          }
        }
      }

      handleSelectionChange() {
        const sel = window.getSelection();
        if (!sel || sel.rangeCount === 0 || sel.isCollapsed) {
          this.hide();
          return;
        }

        const range = sel.getRangeAt(0);

        // Ignore selections inside our own feedback UI
        const common =
          range.commonAncestorContainer instanceof Element
            ? range.commonAncestorContainer
            : range.commonAncestorContainer.parentElement;
        if (
          common &&
          (common.closest(".floating-feedback-container") ||
            common.closest(".feedback-popup") ||
            common.closest(".feedback-indicator") ||
            common.closest(".feedback-compose") ||
            common.closest(".feedback-selection-prompt"))
        ) {
          this.hide();
          return;
        }

        if (!this.root || !document.body.contains(this.root)) {
          this.root = this.resolveRoot(this.rootSelector);
        }

        const root = this.root || document.body;
        const probe = common || range.commonAncestorContainer;
        const probeElement =
          probe instanceof Element ? probe : probe?.parentElement;
        if (probeElement && !root.contains(probeElement)) {
          this.hide();
          return;
        }

        const text = sel.toString().trim();
        if (!text || text.length < 3) {
          this.hide();
          return;
        }

        // Cache current range and text for click, since clicking the prompt collapses selection
        this.lastRange = range.cloneRange();
        this.lastText = text;

        this.show(range);
      }

      onPromptClick(e) {
        e.preventDefault();
        // Use cached selection if the native selection collapsed after clicking
        let range = this.lastRange;
        let text = this.lastText;
        const sel = window.getSelection();
        if (
          (!range || !text) &&
          sel &&
          sel.rangeCount > 0 &&
          !sel.isCollapsed
        ) {
          range = sel.getRangeAt(0).cloneRange();
          text = sel.toString().trim();
        }
        if (!range || !text || text.length < 3) return;
        const ctx = this.computeContext(range);
        let segments = [];
        try {
          const root = this.root || document.body;
          segments = buildSegmentsFromRange(root, range) || [];
        } catch {}
        try {
          console.debug(
            "[FloatingFeedback]",
            "compose: computed segments for selection",
            { length: segments?.length || 0, segments },
          );
        } catch {}
        // Create a temporary highlight wrapper to preserve visual emphasis when selection blurs
        const span = document.createElement("span");
        span.className = "feedback-highlight feedback-highlight--temp";
        const frag = range.extractContents();
        span.appendChild(frag);
        range.insertNode(span);
        this.tempHighlight = span;
        // Clear the native selection so focusing the popup doesn't reflow the page
        sel.removeAllRanges();
        this.hide();
        // Show compose popup near the highlighted text
        this.showComposer({
          quote: text,
          anchor: span,
          context: ctx,
          segments,
        });
      }

      showComposer({ quote, anchor, preset, context, segments }) {
        const existing = document.querySelector(".feedback-compose");
        if (existing) existing.remove();
        const popup = document.createElement("div");
        popup.className = "feedback-compose";
        popup.innerHTML = `
        <div class="compose-header">
          <h4 class="compose-title">Add Feedback</h4>
          <button class="compose-close" aria-label="Close">&times;</button>
        </div>
        <div class="compose-body">
          <div class="compose-quote">${this.escapeHtml(quote)}</div>
          <label for="feedback-compose-text" style="display:none">Feedback</label>
          <textarea id="feedback-compose-text" placeholder="What would you like to tell us?" autofocus></textarea>
        </div>
        <div class="compose-actions">
          <div class="compose-actions-auth" data-auth="unknown">
            <span class="compose-auth-status" style="flex:1; font-size:12px; color:#6b7280"></span>
            <button class="btn" data-action="cancel">Cancel</button>
            <button class="btn btn-primary" data-action="submit">Submit</button>
            <button class="btn btn-primary" data-action="login" style="display:none">Sign in with GitHub</button>
          </div>
        </div>
      `;
        document.body.appendChild(popup);

        const position = () => {
          const rect = anchor.getBoundingClientRect();
          let left = rect.left;
          let top = rect.bottom + 10;
          const width = Math.min(460, window.innerWidth - 32);
          if (left + width > window.innerWidth - 8)
            left = Math.max(8, window.innerWidth - width - 8);
          if (top + 280 > window.innerHeight) top = Math.max(8, rect.top - 300);
          popup.style.left = `${Math.round(left)}px`;
          popup.style.top = `${Math.round(top)}px`;
        };
        position();
        // animate in
        requestAnimationFrame(() => popup.classList.add("is-visible"));

        let currentSegments = Array.isArray(segments) ? [...segments] : [];
        const ensureSegments = () => {
          if (Array.isArray(currentSegments) && currentSegments.length > 0)
            return currentSegments;
          try {
            if (anchor && anchor instanceof Node) {
              const range = document.createRange();
              if (anchor instanceof Text) {
                range.selectNode(anchor);
              } else {
                range.selectNodeContents(anchor);
              }
              const root = this.root || document.body;
              const rebuilt = buildSegmentsFromRange(root, range) || [];
              if (Array.isArray(rebuilt) && rebuilt.length > 0) {
                currentSegments = rebuilt;
                try {
                  console.debug(
                    "[FloatingFeedback]",
                    "compose: rebuilt segments from anchor",
                    { length: rebuilt.length, segments: rebuilt },
                  );
                } catch {}
              }
            }
          } catch (err) {
            try {
              console.debug(
                "[FloatingFeedback]",
                "compose: failed to rebuild segments",
                err,
              );
            } catch {}
          }
          if (!currentSegments || currentSegments.length === 0) {
            try {
              console.debug(
                "[FloatingFeedback]",
                "compose: no segments available for submission",
              );
            } catch {}
          }
          return currentSegments || [];
        };

        // Auth gate: check if user is logged in
        const authWrap = popup.querySelector(".compose-actions-auth");
        const authNote = popup.querySelector(".compose-auth-status");
        const btnSubmit = popup.querySelector('[data-action="submit"]');
        const btnLogin = popup.querySelector('[data-action="login"]');
        const setAuth = (loggedIn) => {
          if (!authWrap) return;
          authWrap.setAttribute("data-auth", loggedIn ? "yes" : "no");
          if (authNote)
            authNote.textContent = loggedIn
              ? ""
              : "Sign in to submit feedback.";
          if (btnSubmit) btnSubmit.style.display = loggedIn ? "" : "none";
          if (btnLogin) btnLogin.style.display = loggedIn ? "none" : "";
        };
        fetch("/api/auth/github/me")
          .then((r) => setAuth(r.ok))
          .catch(() => setAuth(false));

        const textarea = popup.querySelector("textarea");
        if (preset && textarea) {
          try {
            textarea.value = preset;
          } catch {}
        }
        setTimeout(() => textarea && textarea.focus(), 50);

        const close = () => {
          popup.remove();
          // Remove temp highlight on cancel. If submission succeeded we already converted it.
          if (this.tempHighlight && this.tempHighlight.parentNode) {
            const frag = document.createDocumentFragment();
            while (this.tempHighlight.firstChild)
              frag.appendChild(this.tempHighlight.firstChild);
            this.tempHighlight.replaceWith(frag);
            this.tempHighlight = null;
          }
        };
        popup.querySelector(".compose-close")?.addEventListener("click", close);
        popup
          .querySelector('[data-action="cancel"]')
          ?.addEventListener("click", close);

        // Login button: persist draft and redirect
        popup
          .querySelector('[data-action="login"]')
          ?.addEventListener("click", () => {
            try {
              const ta = popup.querySelector("textarea");
              const draft = ta ? ta["value"] || "" : "";
              sessionStorage.setItem("fz_feedback_draft", draft);
              sessionStorage.setItem("fz_feedback_quote", quote);
              const temp = document.querySelector(".feedback-highlight--temp");
              if (
                temp &&
                typeof temp === "object" &&
                typeof temp["getBoundingClientRect"] === "function"
              ) {
                const r = temp["getBoundingClientRect"]();
                const rect = {
                  left: r.left,
                  top: r.top,
                  right: r.right,
                  bottom: r.bottom,
                };
                sessionStorage.setItem(
                  "fz_feedback_rect",
                  JSON.stringify(rect),
                );
              }
            } catch {}
            const state = (typeof getState === "function"
              ? getState()
              : null) || { slug: location.pathname };
            const returnTo = encodeURIComponent(
              state.slug || location.pathname,
            );
            location.href = `/api/auth/github/login?returnTo=${returnTo}`;
          });

        const onSubmit = async () => {
          const ta = popup.querySelector("textarea");
          const message = ta ? String((ta && ta["value"]) || "").trim() : "";
          if (!message) {
            if (ta && typeof ta["focus"] === "function") ta["focus"]();
            return;
          }
          const state = (typeof getState === "function"
            ? getState()
            : null) || { slug: null };
          const segs = ensureSegments();
          const payload = {
            slug: state.slug || location.pathname,
            selection: {
              text: quote,
              context: context || null,
              segments: segs,
            },
            message,
          };
          try {
            console.debug(
              "[FloatingFeedback]",
              "compose: submitting feedback",
              payload,
            );
          } catch {}
          try {
            const result = await submitFeedback(payload);
            if (!result.ok && result.status === 401) {
              if (authWrap) setAuth(false);
              return;
            }
            if (this.tempHighlight && this.tempHighlight.parentNode) {
              const frag = document.createDocumentFragment();
              while (this.tempHighlight.firstChild)
                frag.appendChild(this.tempHighlight.firstChild);
              this.tempHighlight.replaceWith(frag);
              this.tempHighlight = null;
            }
            popup.remove();
          } catch (err) {
            console.error(err);
            const btn = popup.querySelector('[data-action="submit"]');
            if (btn) {
              btn.textContent = "Retry";
            }
          }
        };
        popup
          .querySelector('[data-action="submit"]')
          ?.addEventListener("click", onSubmit);

        const onOutside = (evt) => {
          if (!popup.contains(evt.target)) {
            document.removeEventListener("mousedown", onOutside);
            close();
          }
        };
        setTimeout(() => document.addEventListener("mousedown", onOutside), 50);

        let ticking = false;
        const onScrollResize = () => {
          if (!ticking) {
            requestAnimationFrame(() => {
              position();
              ticking = false;
            });
            ticking = true;
          }
        };
        window.addEventListener("scroll", onScrollResize, { passive: true });
        window.addEventListener("resize", onScrollResize);
      }

      computeContext(range) {
        const ctx = { prefix: "", suffix: "" };
        try {
          const sc = range.startContainer;
          const ec = range.endContainer;
          if (sc && sc.nodeType === Node.TEXT_NODE) {
            const data = sc.nodeValue || "";
            const off = range.startOffset || 0;
            ctx.prefix = data.slice(Math.max(0, off - 40), off);
          }
          if (ec && ec.nodeType === Node.TEXT_NODE) {
            const data2 = ec.nodeValue || "";
            const off2 = range.endOffset || 0;
            ctx.suffix = data2.slice(off2, Math.min(data2.length, off2 + 40));
          }
        } catch {}
        return ctx;
      }

      // Restore draft after OAuth login: re-anchor by matching the saved quote, else use last known rect
      restoreFromSession() {
        try {
          const quote = sessionStorage.getItem("fz_feedback_quote");
          const draft = sessionStorage.getItem("fz_feedback_draft");
          const rectStr = sessionStorage.getItem("fz_feedback_rect");
          if (!quote) return;
          let anchor = null;
          const loc = this.findTextInPage(quote);
          if (loc) {
            const span = document.createElement("span");
            span.className = "feedback-highlight feedback-highlight--temp";
            const frag = loc.range.extractContents();
            span.appendChild(frag);
            loc.range.insertNode(span);
            anchor = span;
            this.tempHighlight = span;
          } else {
            const fallback = document.createElement("div");
            fallback.style.position = "fixed";
            const rect = rectStr ? JSON.parse(rectStr) : null;
            const left = rect?.left ?? 16;
            const top = rect?.bottom ?? 100;
            fallback.style.left = `${Math.round(left)}px`;
            fallback.style.top = `${Math.round(top)}px`;
            fallback.style.width = "1px";
            fallback.style.height = "1px";
            fallback.style.pointerEvents = "none";
            document.body.appendChild(fallback);
            anchor = fallback;
          }
          try {
            if (anchor && typeof anchor["scrollIntoView"] === "function") {
              anchor["scrollIntoView"]({
                behavior: "instant",
                block: "center",
              });
            }
          } catch {}
          setTimeout(
            () => this.showComposer({ quote, anchor, preset: draft || "" }),
            60,
          );
        } catch {}
        try {
          sessionStorage.removeItem("fz_feedback_quote");
        } catch {}
        try {
          sessionStorage.removeItem("fz_feedback_draft");
        } catch {}
        try {
          sessionStorage.removeItem("fz_feedback_rect");
        } catch {}
      }

      findTextInPage(selectedText) {
        if (!selectedText) return null;
        const root = this.root || document.body;
        const walker = document.createTreeWalker(root, NodeFilter.SHOW_TEXT, {
          acceptNode(node) {
            const parent = node.parentElement;
            if (!parent) return NodeFilter.FILTER_REJECT;
            const tag = parent.tagName;
            if (tag === "SCRIPT" || tag === "STYLE")
              return NodeFilter.FILTER_REJECT;
            return NodeFilter.FILTER_ACCEPT;
          },
        });
        let node;
        while ((node = walker.nextNode())) {
          const text = node.textContent || "";
          const index = text.indexOf(selectedText);
          if (index !== -1) {
            const range = document.createRange();
            range.setStart(node, index);
            range.setEnd(node, index + selectedText.length);
            return { range, element: node.parentElement, text: selectedText };
          }
        }
        return null;
      }

      escapeHtml(s) {
        return s
          .replace(/&/g, "&amp;")
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;");
      }

      position(range) {
        const rect = range.getBoundingClientRect();
        const el = this.ensureEl();
        const padding = 8;
        const promptWidth = 160;
        const promptHeight = 34;

        let left = rect.right + padding;
        let top = rect.top - promptHeight - 4;

        if (left + promptWidth > window.innerWidth - 8) {
          left = Math.max(8, rect.left - promptWidth - padding);
        }
        if (top < 8) {
          top = Math.min(
            window.innerHeight - promptHeight - 8,
            rect.bottom + 6,
          );
        }

        el.style.left = `${Math.round(left)}px`;
        el.style.top = `${Math.round(top)}px`;
      }

      show(range) {
        const el = this.ensureEl();
        this.position(range);
        el.style.display = "flex";
        el.style.opacity = "1";
      }

      hide() {
        if (this.el) {
          this.el.style.display = "none";
          this.el.style.opacity = "0";
        }
      }
    }

    const boot = () => {
      const ctrl = new SelectionPromptController(rootSelector, mountId);
      ctrl.restoreFromSession();
    };
    if (document.readyState === "loading") {
      document.addEventListener("DOMContentLoaded", boot, { once: true });
    } else {
      boot();
    }
  }
</script>
