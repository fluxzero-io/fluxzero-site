---
title: Aggregate
description: Understanding aggregates as consistency boundaries in Fluxzero
sidebar:
   order: 5
---

import { Tabs, TabItem, Card, CardGrid, Aside } from '@astrojs/starlight/components';

An Aggregate is a specialized root entity that serves as the entry point into a domain model.
It represents a single unit of consistency and can contain nested child entities.

Aggregates in Fluxzero act as consistency boundaries. They’re not required for every model, but when you need atomic updates across related entities, an aggregate is the right tool.

<Aside type="tip" title="Real-world analogy">
Think of an aggregate like a smart home system. The smart home (aggregate root) manages all connected devices (entities) as one cohesive unit. You can't control individual devices without going through the home, ensuring everything stays synchronized.
</Aside>

## Key concepts

<CardGrid>
<Card title="Consistency Boundary" icon="approve-check">
Aggregates ensure that all changes within the boundary happen together or not at all, maintaining data consistency across related entities.
</Card>

<Card title="Single Entry Point" icon="rocket">
All access to entities within an aggregate must go through the aggregate root, controlling how data can be modified.
</Card>

<Card title="Event Sourcing" icon="document">
By default, aggregates are event-sourced: every change is captured as an event you can replay to rebuild state. Prefer document storage if that’s a better fit.
</Card>

<Card title="Nested Entities" icon="list-format">
Aggregates can contain child entities with their own identities, creating rich domain models with complex relationships.
</Card>
</CardGrid>

## Defining aggregates

### Basic aggregate

<Tabs>
<TabItem label="Java">
```java
@Aggregate
@Builder(toBuilder = true)
public record SmartHome(@EntityId HomeId homeId,
                        HomeDetails details,
                        boolean alarmEnabled) {
    // Aggregate root for home automation system
}
```
</TabItem>
<TabItem label="Kotlin">
```kotlin
@Aggregate
data class SmartHome(@EntityId val homeId: HomeId,
                     val details: HomeDetails,
                     val alarmEnabled: Boolean) {
    // Aggregate root for home automation system
}
```
</TabItem>
</Tabs>

### Aggregate with child entities

<Tabs>
<TabItem label="Java">
```java
@Aggregate
@Builder(toBuilder = true)
public record SmartHome(@EntityId HomeId homeId,
                        HomeDetails details,
                        @Member @With List<Room> rooms) {
}

public record Room(@EntityId RoomId roomId,
                   RoomDetails details,
                   @Member @With List<Device> devices) {
}

public record Device(@EntityId DeviceId deviceId,
                     DeviceDetails details,
                     boolean online,
                     String status) {
}
```
</TabItem>
<TabItem label="Kotlin">
```kotlin
@Aggregate
data class SmartHome(@EntityId val homeId: HomeId,
                     val details: HomeDetails,
                     @Member val rooms: List<Room> = emptyList()) {
}

data class Room(@EntityId val roomId: RoomId,
                val details: RoomDetails,
                @Member val roomDevices: List<Device> = emptyList()) {
}

data class Device(@EntityId val deviceId: DeviceId,
                  val details: DeviceDetails,
                  val online: Boolean,
                  val status: String) {
}
```
</TabItem>
</Tabs>

## Strongly typed identifiers

Use strongly typed identifiers extending `Id<T>` for better type safety:

<Tabs>
<TabItem label="Java">
```java
public class HomeId extends Id<SmartHome> {
    public HomeId(String id) {
        super(id);
    }
}

public class RoomId extends Id<Room> {
    public RoomId(String id) {
        super(id);
    }
}

public class DeviceId extends Id<Device> {
    public DeviceId(String id) {
        super(id);
    }
}
```
</TabItem>
<TabItem label="Kotlin">
```kotlin
class HomeId(id: String) : Id<SmartHome>(id)

class RoomId(id: String) : Id<Room>(id)

class DeviceId(id: String) : Id<Device>(id)
```
</TabItem>
</Tabs>

`Id<T>` supports prefixing, case-insensitive matching, and simply serialize to string.

## Loading aggregates

Fluxzero provides several ways to load aggregates and their entities:

### Load by aggregate ID

<Tabs>
<TabItem label="Java">
```java
// Load complete smart home aggregate
Entity<SmartHome> home = Fluxzero.loadAggregate(homeId);
```
</TabItem>
<TabItem label="Kotlin">
```kotlin
// Load complete smart home aggregate
val homeAggregate = Fluxzero.loadAggregate(homeId)
```
</TabItem>
</Tabs>

### Load by entity ID

<Tabs>
<TabItem label="Java">
```java
// Load an aggregate or entity to apply updates
Entity<SmartHome> home = Fluxzero.loadAggregateFor(roomId);
Entity<Room> room = Fluxzero.loadEntity(roomId);

// Or just load the current value (read-only)
Room roomValue = Fluxzero.loadEntityValue(roomId);
Device device = Fluxzero.loadEntityValue(deviceId);
```
</TabItem>
<TabItem label="Kotlin">
```kotlin
// Load an aggregate or entity to apply updates
val home = Fluxzero.loadAggregateFor(roomId)
val room = Fluxzero.loadEntity(roomId)

// Or just load the current value (read-only)
val roomValue = Fluxzero.loadEntityValue(roomId)
val device = Fluxzero.loadEntityValue(deviceId)
```
</TabItem>
</Tabs>

<Aside type="tip">
    Use `Entity<T>` whenever you need to validate business rules or apply updates. Use `loadEntityValue(...)` only for read-only access.
</Aside>

## Persistence behavior

By default, aggregates are event-sourced. You can change this per aggregate or combine event streams with document snapshots.

You can customize event persistence behavior with:

- `eventPublication`: prevent events when nothing has changed
- `publicationStrategy`: store-only vs publish-and-store
- `snapshotPeriod`: replace snapshot after every N updates
- `ignoreUnknownEvents`: handle versioned aggregates gracefully

Here’s a simple example:

```java

@Aggregate(snapshotPeriod = 1000)
public record UserAccount(@EntityId UserId userId,
                          UserProfile profile) {
}
```

This stores a snapshot of the aggregate after every thousand events.

<Aside type="note">
Snapshotting can speed up loading large aggregates (many updates) by avoiding full event replays.

But be mindful: snapshots are only as fresh as the last checkpoint. If corrupted or misapplied, they can hide issues that a clean replay would reveal. Use snapshots to improve performance, but don’t rely on them as your source of truth.
</Aside>

### Document storage

Fluxzero also supports storing aggregates as documents in a searchable document store. This is useful for:

- Read-heavy aggregates
- Aggregates with large histories
- Reference models that don’t need event streams

To enable document storage, set `searchable = true` in the `@Aggregate` annotation:

```java

@Aggregate(eventSourced = false, searchable = true, collection = "countries")
public record Country(@EntityId String countryCode,
                      String name) {
}
```

This stores the entire aggregate as a document in the `"countries"` collection.

<Aside type="tip">
Document storage is especially useful when aggregates are large, frequently queried, or don’t need full event history.
</Aside>


<Aside type="note">
Aggregates are not the only way to model state in Fluxzero — you can also use [stateful handlers](/docs/guides/modeling--persistence/210-stateful-handlers/) or manually indexed documents.
</Aside>
