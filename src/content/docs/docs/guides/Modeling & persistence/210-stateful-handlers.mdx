---
title: Stateful handlers
description: Modeling long-lived, stateful handlers with Fluxzero
slug: docs/guides/modeling-and-persistence/stateful-handlers
sidebar:
   order: 210
---

import { Tabs, TabItem } from '@astrojs/starlight/components';
import { Aside } from '@astrojs/starlight/components';

While aggregates represent domain entities, Fluxzero also supports long-lived **stateful handlers** for modeling workflows,
external interactions, or background processes that span multiple messages.

To declare a stateful handler, annotate a class with `@Stateful`:

<Tabs>
  <TabItem label="Java">
    ```java
    @Stateful
    public record PaymentProcess(@EntityId String paymentId,
                                 @Association String pspReference,
                                 PaymentStatus status) {

        @HandleEvent
        static PaymentProcess on(PaymentInitiated event) {
            String pspRef = Fluxzero.sendCommandAndWait(new ExecutePayment(...));
            return new PaymentProcess(event.getPaymentId(), pspRef, PaymentStatus.PENDING);
        }

        @HandleEvent
        PaymentProcess on(PaymentConfirmed event) {
            // pspReference property in PaymentConfirmed is matched
            return withStatus(PaymentStatus.CONFIRMED);
        }
    }
    ```
  </TabItem>
  <TabItem label="Kotlin">
    ```kotlin
    @Stateful
    data class PaymentProcess(
        @EntityId val paymentId: String,
        @Association val pspReference: String,
        val status: PaymentStatus
    ) {

        companion object {
            @HandleEvent
            fun on(event: PaymentInitiated): PaymentProcess {
                val pspRef = Fluxzero.sendCommandAndWait(ExecutePayment(...))
                return PaymentProcess(event.paymentId, pspRef, PaymentStatus.PENDING)
            }
        }

        @HandleEvent
        fun on(event: PaymentConfirmed): PaymentProcess {
            // pspReference property in PaymentConfirmed is matched
            return copy(status = PaymentStatus.CONFIRMED)
        }
    }
    ```
  </TabItem>
</Tabs>

## Key properties

- `@Stateful` classes persist their state using Fluxzero’s document store (or a custom `HandlerRepository`)
- They are automatically invoked when messages match their associations (`@Association` fields or methods)
- Matching is dynamic and supports multiple handler instances per message
- Multiple handler methods can exist for different message types
- Handlers are immutable by convention — they are updated by returning a new version of themselves
- Returning `null` deletes the handler (useful for terminating flows)

<Aside type="note">
Like other handlers, stateful handlers may be annotated with `@Consumer` for tracking isolation.
</Aside>

<Tabs>
  <TabItem label="Java">
    ```java
    @HandleEvent
    PaymentProcess on(PaymentFailed event) {
        return null; // remove from store
    }
    ```
  </TabItem>
  <TabItem label="Kotlin">
    ```kotlin
    @HandleEvent
    fun on(event: PaymentFailed): PaymentProcess? {
        return null // remove from store
    }
    ```
  </TabItem>
</Tabs>

## Matching via association

Handlers are selected based on one or more `@Association` fields. When a message with a matching association is
published, the handler is loaded and invoked.

<Tabs>
  <TabItem label="Java">
    ```java
    @Association
    String pspReference;
    ```
  </TabItem>
  <TabItem label="Kotlin">
    ```kotlin
    @Association
    val pspReference: String
    ```
  </TabItem>
</Tabs>

<Aside type="note">
This is similar to correlation IDs or saga keys — but built-in and fully indexed.
</Aside>

## State update semantics

- If the handler method returns a new instance of its class, it replaces the previous version in the store
- If it returns `void` or a value of another type, state is left unchanged
- This allows safe utility returns (like `Duration` for `@HandleSchedule`)

<Tabs>
  <TabItem label="Java">
    ```java
    @HandleSchedule
    Duration on(CheckStatus schedule) {
        // Return next delay (but don’t update handler state)
        return Duration.ofMinutes(5);
    }
    ```
  </TabItem>
  <TabItem label="Kotlin">
    ```kotlin
    @HandleSchedule
    fun on(schedule: CheckStatus): Duration {
        // Return next delay (but don’t update handler state)
        return Duration.ofMinutes(5)
    }
    ```
  </TabItem>
</Tabs>

## Batch commit control

By default, changes to a `@Stateful` handler are persisted immediately. Set `commitInBatch = true` to defer updates
until the current message batch completes. Fluxzero ensures that:

- Newly created handlers are matched by subsequent messages
- Deleted handlers won’t receive more messages in the batch
- Updates are consistent within the batch

<Aside type="note">
This dramatically improves performance for high-throughput workflows.
</Aside>

## Indexing support

Stateful handlers are automatically `@Searchable`. You can configure:

- A custom collection name
- Time-based indexing fields (e.g. `timestampPath` or `endPath`)

This allows you to query, filter, and monitor stateful handlers using Fluxzero’s search API — covered in the next section.

---

Stateful handlers are ideal for:

- **Workflows** and **sagas**
- **Pollers**, **reminders**, and **background jobs**
- External **API orchestrations**
- **Process managers** (e.g., order fulfillment, payment retry, etc.)

They complement aggregates without competing with them — and allow modeling temporal behavior in a clean, event-driven way.

## Invocation flow

The following diagram shows how a `@Stateful` handler is matched, loaded, invoked, and updated:

```mermaid
graph TD
    MSG[Incoming message] --> CHECK[Inspect payload for possible association match]
    CHECK -->|No match| SKIP[Skip handler]
    CHECK -->|Potential match| LOOKUP[Lookup persisted handler via @Association properties]

    LOOKUP -->|Not found & factory method exists| CREATE[Invoke static factory @Handle... method]
    LOOKUP -->|Found| LOAD[Load and deserialize handler state]

    CREATE --> INVOKE[Invoke handler with message]
    LOAD --> INVOKE[Invoke handler with message]

    INVOKE --> RETURN{Handler return value?}
    RETURN -->|Same type instance| UPDATE[Persist new handler state]
    RETURN -->|"null (with compatible return type)"| DELETE[Delete handler from store]
    RETURN -->|Other type or void| KEEP[Keep existing state]
```

1. The message payload is inspected to see if any `@Association` values might match.
2. If there’s a possible match, Fluxzero looks up the persisted handler document by association.
3. If a handler is not found but a static factory method or constructor (`@Handle...`) exists, that method is invoked to create a new handler.
4. If a persisted handler is found, its state is loaded and deserialized.
5. The handler is invoked with the incoming message.
6. The return value determines what happens next:
   - Returning a new instance of the handler type → the handler state is re-persisted with the updated values.
   - Returning `null` (with a compatible return type) → the handler is deleted from the store.
   - Returning another type or `void` → the state remains unchanged (useful for utility responses such as durations or acknowledgments).

<Aside type="note">
This entire process typically runs behind a **message tracker**, which continuously delivers messages to eligible stateful handlers. It’s not an on-demand invocation, but part of Fluxzero’s ongoing tracking loop.
</Aside>

