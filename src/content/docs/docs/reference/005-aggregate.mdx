---
title: Aggregate
description: Understanding aggregates as consistency boundaries in Fluxzero
sidebar:
   order: 5
---

import { Tabs, TabItem, Card, CardGrid, Aside } from '@astrojs/starlight/components';

An Aggregate is a specialized root entity that serves as the entry point into a domain model.
It represents a single unit of consistency and can contain nested child entities.
Aggregates are the foundation of domain-driven design in Fluxzero.

<Aside type="tip" title="Real-world analogy">
Think of an aggregate like a smart home system. The smart home (aggregate root) manages all connected devices (entities) as one cohesive unit. You can't control individual devices without going through the home, ensuring everything stays synchronized.
</Aside>

## Key Concepts

<CardGrid>
<Card title="Consistency Boundary" icon="approve-check">
Aggregates ensure that all changes within the boundary happen together or not at all, maintaining data consistency across related entities.
</Card>

<Card title="Single Entry Point" icon="rocket">
All access to entities within an aggregate must go through the aggregate root, controlling how data can be modified.
</Card>

<Card title="Event Sourcing" icon="document">
By default, aggregates use event sourcing to track all changes as a sequence of events that can be replayed to rebuild state.
</Card>

<Card title="Nested Entities" icon="list-format">
Aggregates can contain child entities with their own identities, creating rich domain models with complex relationships.
</Card>
</CardGrid>

## Defining Aggregates

### Basic Aggregate

<Tabs>
<TabItem label="Java">
```java
@Aggregate
@Builder(toBuilder = true)
public record SmartHome(@EntityId HomeId homeId,
                        String address,
                        boolean securityEnabled) {
    // Aggregate root for home automation system
}
```
</TabItem>
<TabItem label="Kotlin">
```kotlin
@Aggregate
data class SmartHome(@EntityId val homeId: HomeId,
                     val address: String,
                     val securityEnabled: Boolean) {
    // Aggregate root for home automation system
}
```
</TabItem>
</Tabs>

### Aggregate with Child Entities

<Tabs>
<TabItem label="Java">
```java
@Aggregate
@Builder(toBuilder = true)
public record SmartHome(@EntityId HomeId homeId,
                        HomeDetails details,
                        @Member @With List<Room> rooms,
                        @Member @With List<Device> devices) {
}

public record Room(@EntityId RoomId roomId,
                   RoomDetails details,
                   @Member @With List<Device> devices) {
}

public record Device(@EntityId DeviceId deviceId,
                     DeviceDetails details,
                     boolean online,
                     String status) {
}
```
</TabItem>
<TabItem label="Kotlin">
```kotlin
@Aggregate
data class SmartHome(@EntityId val homeId: HomeId,
                     val details: HomeDetails,
                     @Member val rooms: List<Room> = emptyList(),
                     @Member val devices: List<Device> = emptyList()) {
}

data class Room(@EntityId val roomId: RoomId,
                val details: RoomDetails,
                @Member val roomDevices: List<Device> = emptyList()) {
}

data class Device(@EntityId val deviceId: DeviceId,
                  val details: DeviceDetails,
                  val online: Boolean,
                  val status: String) {
}
```
</TabItem>
</Tabs>

## Strongly Typed Identifiers

Use strongly typed identifiers extending `Id<T>` for better type safety:

<Tabs>
<TabItem label="Java">
```java
public class HomeId extends Id<SmartHome> {
    public HomeId(String id) {
        super(id);
    }
}

public class RoomId extends Id<Room> {
    public RoomId(String id) {
        super(id);
    }
}

public class DeviceId extends Id<Device> {
    public DeviceId(String id) {
        super(id);
    }
}
```
</TabItem>
<TabItem label="Kotlin">
```kotlin
class HomeId(id: String) : Id<SmartHome>(id)

class RoomId(id: String) : Id<Room>(id)

class DeviceId(id: String) : Id<Device>(id)
```
</TabItem>
</Tabs>

## Loading Aggregates

Fluxzero provides several ways to load aggregates and their entities:

### Load by Aggregate ID

<Tabs>
<TabItem label="Java">
```java
// Load complete smart home aggregate
Entity<SmartHome> home = FluxCapacitor.loadAggregate(homeId);
```
</TabItem>
<TabItem label="Kotlin">
```kotlin
// Load complete smart home aggregate
val homeAggregate = FluxCapacitor.loadAggregate(homeId)
```
</TabItem>
</Tabs>

### Load by Entity ID

<Tabs>
<TabItem label="Java">
```java
// Load aggregate containing a specific room
SmartHome home = FluxCapacitor.loadAggregateFor(roomId).get();

// Load just the room entity
Room room = FluxCapacitor.loadEntity(roomId).get();

// Load just the device entity
Device device = FluxCapacitor.loadEntity(deviceId).get();
```
</TabItem>
<TabItem label="Kotlin">
```kotlin
// Load aggregate containing a specific room
val home = FluxCapacitor.loadAggregateFor(roomId).get()

// Load just the room entity
val room = FluxCapacitor.loadEntity(roomId).get()

// Load just the device entity
val device = FluxCapacitor.loadEntity(deviceId).get()
```
</TabItem>
</Tabs>

## Persistence Behavior

You can customize event persistence behavior with:

- `eventPublication`: prevent events when nothing has changed
- `publicationStrategy`: store-only vs publish-and-store
- `snapshotPeriod`: replace snapshot after every N updates
- `ignoreUnknownEvents`: handle versioned aggregates gracefully

Here’s a simple example:

```java

@Aggregate(snapshotPeriod = 1000)
public record UserAccount(@EntityId UserId userId,
                          UserProfile profile) {
}
```

This stores a snapshot of the aggregate after every thousand events.

### Document Storage

Fluxzero also supports storing aggregates as documents in a searchable document store. This is useful for:

- Read-heavy aggregates
- Aggregates with large histories
- Reference models that don’t need event streams

To enable document storage, set `searchable = true` in the `@Aggregate` annotation:

```java

@Aggregate(eventSourced = false, searchable = true, collection = "countries")
public record Country(@EntityId String countryCode,
                      String name) {
}
```

This stores the entire aggregate as a document in the `"countries"` collection.