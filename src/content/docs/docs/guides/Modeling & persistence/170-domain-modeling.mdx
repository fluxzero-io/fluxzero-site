---
title: Domain modeling
sidebar:
   order: 170
---

import { Aside, Tabs, TabItem } from '@astrojs/starlight/components';

Fluxzero allows you to model the state of your domain using entities that evolve over time by applying updates.
These entities â€” such as users, orders, etc. â€” maintain state and enforce invariants through controlled updates,
typically driven by commands.

## Defining the Aggregate Entity

To define a stateful domain object, annotate it with `@Aggregate`:

```java

@Aggregate
@Builder(toBuilder = true)
public record UserAccount(@EntityId UserId userId,
                          UserProfile profile,
                          boolean accountClosed) {
}
```

This `UserAccount` class models an aggregate with state such as `profile` and `accountClosed`. Each entity may contain a
field
annotated with `@EntityId` that acts as a unique identifier. For aggregates, this is optional â€” the aggregate itself is
typically loaded using `Fluxzero.loadAggregate(id)`.

An **aggregate** is a specialized root entity that serves as an entry point into a domain model. It may contain nested
child entities (modeled via `@Member`), but represents a single unit of consistency.

## ðŸ’¡ **Tip:** Use strongly typed identifiers

While `@EntityId` can be placed on any object (e.g. a `String` or `UUID`), consider using a strongly typed `Id<T>` class
instead. This lets you:

- Enforce consistent ID prefixes (e.g. `"user-"`)
- Avoid collisions between entities with the same functional ID
- Enable case-insensitive matching (optional)
- Retain type information for safer entity loading and deserialization

```java
class UserId extends Id<UserAccount> {
    public UserId(String value) {
        super(value, "user-");
    }
}

@Aggregate
public record UserAccount(@EntityId UserId userId) {
}
```

Now you can easily load the entity via:

```java
Entity<UserAccount> user = Fluxzero.loadAggregate(new UserId("1234"));
```

---

## Applying Updates to entities

Entities evolve in response to **updates** â€” typically the payload of a command. Updates define what change should
happen and contain the logic to validate and apply those changes.

Hereâ€™s an example using two commands â€” one to create a user, and another to update their profile.

```java

public record CreateUser(UserId userId,
                         UserProfile profile) {

    @AssertLegal
    void assertNotExists(UserAccount current) {
        throw new IllegalCommandException("Account already exists");
    }

    @Apply
    UserAccount apply() {
        return new UserAccount(userId, profile, false);
    }
}
```

This update creates a new `UserAccount` entity after checking that no user with the same ID currently exists.

```java

public record UpdateProfile(UserId userId,
                            UserProfile profile) {

    @AssertLegal
    void assertExists(@Nullable UserAccount current) {
        if (current == null) {
            throw new IllegalCommandException("Account not found");
        }
    }

    @AssertLegal
    void assertAccountNotClosed(UserAccount current) {
        if (current.isAccountClosed()) {
            throw new IllegalCommandException("Account is closed");
        }
    }

    @Apply
    UserAccount apply(UserAccount current) {
        return current.toBuilder().profile(profile).build();
    }
}
```

This update first ensures the user exists and their account isnâ€™t closed before applying the change.

> **Note**: Handler method parameters (like `UserAccount current`) are only injected if non-null. Use `@Nullable`
> to allow for missing values.

---

## Intercepting and Transforming Updates

In addition to applying and validating updates, you can also **intercept** them *before* they reach the legal or apply
phase.

Use `@InterceptApply` to:

- Suppress updates that are irrelevant or no-ops
- Rewrite updates that would otherwise be invalid
- Split a single update into multiple smaller updates

```java

@InterceptApply
Object ignoreNoChange(UserAccount current) {
    if (current.getProfile().equals(profile)) {
        return null; // suppress update, nothing to change
    }
    return this;
}
```

You can even rewrite the update entirely:

```java

@InterceptApply
UpdateProfile downgradeCommand(CreateUser command, UserAccount current) {
    //the current account could be injected, hence it already exists
    return new UpdateProfile(command.getUserId(), command.getProfile());
}
```

Or expand a bulk command into many atomic ones:

```java

@InterceptApply
List<CreateTask> expandBulk(BulkCreateTasks bulk) {
    return bulk.getTasks();
}
```

> ðŸ” Flux will apply interceptors **recursively** until the final update no longer changes.

---

## Invocation Order

The update lifecycle flows as follows:

1. **Intercept** using `@InterceptApply`
2. **Assert legality** using `@AssertLegal`
3. **Apply changes** using `@Apply`

This allows you to rewrite or suppress updates *before* theyâ€™re validated or stored â€” a powerful tool for protecting
data integrity and simplifying update logic.

### Return Values

`@InterceptApply` supports flexible return types:

- `null` or `void` â†’ suppress the update
- `this` â†’ no change
- A **new update object** â†’ rewrites the update
- A **Collection**, `Stream`, or `Optional` â†’ emits zero or more new updates

> ðŸ“Œ You typically donâ€™t need to intercept just to avoid storing no-ops. Instead, annotate the `@Aggregate` or `@Apply`
> method with `eventPublication = IF_MODIFIED` to avoid persisting unchanged state.

---

## Summary

| Annotation        | Purpose                                        | Phase        |
|-------------------|------------------------------------------------|--------------|
| `@InterceptApply` | Rewrite, suppress, or expand updates           | Pre-check    |
| `@AssertLegal`    | Validate preconditions                         | Validation   |
| `@Apply`          | Apply state transformation                     | Execution    |

Together, these annotations offer full control over your entity update lifecycle â€” with a clean, declarative style.

<Aside type="note">
  You may notice we donâ€™t define a separate event class here (like <code>UserCreated</code>).
  In Fluxzero, the same payload often serves as both the command and the published event.

  This has a few advantages:
  - **No duplication**: you donâ€™t have to maintain two nearly identical classes.
  - **Accuracy**: the event log contains exactly what was applied, not a translation of it.
  - **Less drift**: command and event definitions canâ€™t silently diverge over time.

  If you need to enrich or transform the event before itâ€™s published, you can still do so with
  <code>@InterceptApply</code>. But for most cases, reusing the same class keeps your model simpler
  and your audit trail more honest.
</Aside>

---

## Why Keep Logic in the Updates?

While itâ€™s possible to implement domain logic inside entities, this is **generally discouraged**. Instead, it is best
practice to define business logic directly inside **command payloads** â€” the updates themselves.

This update-driven approach has several advantages:

- **Behavior stays with the update** â€“ each update class (e.g. `CreateUser`, `UpdateProfile`) encapsulates its own
  validation and transformation logic.
- **Entities stay focused** â€“ entities remain concise, responsible only for maintaining state and enforcing invariants.
- **Easy feature cleanup** â€“ removing an update class cleanly disables that feature.
- **Traceable domain behavior** â€“ itâ€™s clear what each update does and how it affects the system.

---

## Alternative: Logic in the Entity

Although possible, modeling behavior inside the aggregate can quickly become unmanageable. Here's a glimpse of what that
looks like:

```java

@Aggregate
@Builder(toBuilder = true)
public record UserAccount(@EntityId UserId userId,
                          UserProfile profile,
                          boolean accountClosed) {

    @AssertLegal
    static void assertNotExists(CreateUser update, @Nullable UserAccount user) {
        if (user != null) {
            throw new IllegalCommandException("Account already exists");
        }
    }

    @Apply
    static UserAccount create(CreateUser update) {
        return new UserAccount(update.getUserId(), update.getProfile(), false);
    }

    @AssertLegal
    static void assertExists(UpdateProfile update, @Nullable UserAccount user) {
        if (user == null) {
            throw new IllegalCommandException("Account does not exist");
        }
    }

    @AssertLegal
    void assertAccountNotClosed(UpdateProfile update) {
        if (accountClosed) {
            throw new IllegalCommandException("Account is closed");
        }
    }

    @Apply
    UserAccount update(UpdateProfile update) {
        return toBuilder().profile(update.getProfile()).build();
    }
}
```

In this model, the `UserAccount` aggregate handles all validation and transformation logic. Over time, this
centralization leads to bloat and tight coupling â€” especially in larger systems with many features.

---

## Mixing strategies

Fluxzero allows **mixed approaches**. You can define:

- `@AssertLegal` methods on the command payload
- `@Apply` methods inside the entity
- or vice versa

Just keep in mind: logic that lives in updates is **easier to test, extend, and remove**.