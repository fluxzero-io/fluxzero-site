---
title: Document indexing and search
slug: docs/guides/modeling-and-persistence/document-index-and-search
description: Indexing and querying domain models with Fluxzero
sidebar:
   order: 220
---

import { Tabs, TabItem } from '@astrojs/starlight/components';
import { Aside } from '@astrojs/starlight/components';

Fluxzero provides a powerful and flexible document store that lets you persist and query models using full-text
search, filters, and time-based constraints.

This system is especially useful for:

- Querying across entities (e.g., active users, recent payments)
- Supporting projections for read APIs or dashboards
- Tracking workflows, external states, or business processes
- Replacing the need for a traditional read model database

---

## Manual indexing

You can index any object manually using:

<Tabs>
  <TabItem label="Java">
    ```java
    Fluxzero.index(myObject);
    ```
  </TabItem>
  <TabItem label="Kotlin">
    ```kotlin
    Fluxzero.index(myObject)
    ```
  </TabItem>
</Tabs>

This stores `myObject` in the document store so it can be queried later via `Fluxzero.search(...)`.

- If the object is annotated with `@Searchable`, any declared `collection`, `timestampPath`, or `endPath` will be used.
- If a field is annotated with `@EntityId`, it becomes the document ID. Otherwise, a random ID is generated.
- Timestamps can be inferred from annotated paths or passed explicitly.

You can also specify the collection in which the object should be stored directly:

<Tabs>
  <TabItem label="Java">
    ```java
    Fluxzero.index(myObject, "customCollection");
    ```
  </TabItem>
  <TabItem label="Kotlin">
    ```kotlin
    Fluxzero.index(myObject, "customCollection")
    ```
  </TabItem>
</Tabs>

---

## Searchable domain models

Many models in Fluxzero (e.g. aggregates or stateful handlers) are automatically indexable:

- `@Aggregate(searchable = true)`
- `@Stateful` (implicitly `@Searchable`)
- Directly annotate any POJO with `@Searchable`

<Tabs>
  <TabItem label="Java">
    ```java
    @Aggregate(searchable = true)
    public record UserAccount(@EntityId UserId userId,
                              UserProfile profile,
                              boolean accountClosed) {
    }
    ```
  </TabItem>
  <TabItem label="Kotlin">
    ```kotlin
    @Aggregate(searchable = true)
    data class UserAccount(
        @EntityId val userId: UserId,
        val profile: UserProfile,
        val accountClosed: Boolean
    )
    ```
  </TabItem>
</Tabs>

By default, the collection name is derived from the class’s **simple name** (UserAccount → `"UserAccount"`),
unless explicitly overridden via an annotation like `@Aggregate`, `@Stateful` or `@Searchable` or in the search/index
call:

<Tabs>
  <TabItem label="Java">
    ```java
    @Aggregate(searchable = true, collection = "users", timestampPath = "profile/createdAt")
    ```
  </TabItem>
  <TabItem label="Kotlin">
    ```kotlin
    @Aggregate(searchable = true, collection = "users", timestampPath = "profile/createdAt")
    ```
  </TabItem>
</Tabs>

---

## Querying indexed documents

Use the fluent `search(...)` API:

<Tabs>
  <TabItem label="Java">
    ```java
    List<UserAccount> admins = Fluxzero
            .search("users")
            .match("admin", "profile/role")
            .inLast(Duration.ofDays(30))
            .sortBy("profile/lastLogin", true)
            .fetch(100);
    ```
  </TabItem>
  <TabItem label="Kotlin">
    ```kotlin
    val admins: List<UserAccount> = Fluxzero
        .search("users")
        .match("admin", "profile/role")
        .inLast(Duration.ofDays(30))
        .sortBy("profile/lastLogin", true)
        .fetch(100)
    ```
  </TabItem>
</Tabs>

You can also query by class:

<Tabs>
  <TabItem label="Java">
    ```java
    List<UserAccount> users = Fluxzero
            .search(UserAccount.class)
            .match("Netherlands", "profile.country")
            .fetchAll();
    ```
  </TabItem>
  <TabItem label="Kotlin">
    ```kotlin
    val users: List<UserAccount> = Fluxzero
        .search(UserAccount::class.java)
        .match("Netherlands", "profile.country")
        .fetchAll()
    ```
  </TabItem>
</Tabs>

<Aside type="note">
You can choose to split path segments with either <code>.</code> or <code>/</code>. Both styles are equivalent.
</Aside>

---

## Common filtering constraints

Fluxzero supports a rich set of constraints:

- `lookAhead("cat", paths...)` – search-as-you-type lookups
- `query("*text & (cat* | hat)", paths...)` – full-text search
- `match(value, path)` – field match
- `matchFacet(name, value)` – match field with `@Facet`
- `between(min, max, path)` – numeric or time ranges
- `since(...)`, `before(...)`, `inLast(...)` – temporal filters
- `anyExist(...)` – match if *any* of the fields are present
- Logical operations: `not(...)`, `all(...)`, `any(...)`

<Tabs>
  <TabItem label="Java">
    ```java
    Fluxzero.search("payments")
        .match("FAILED", "status")
        .inLast(Duration.ofDays(1))
        .fetchAll();
    ```
  </TabItem>
  <TabItem label="Kotlin">
    ```kotlin
    Fluxzero.search("payments")
        .match("FAILED", "status")
        .inLast(Duration.ofDays(1))
        .fetchAll()
    ```
  </TabItem>
</Tabs>

---

## Matching facet fields

If you're filtering on a field that is marked with `@Facet`, it's better to use:

<Tabs>
  <TabItem label="Java">
    ```java
    .matchFacet("status", "archived")
    ```
  </TabItem>
  <TabItem label="Kotlin">
    ```kotlin
    .matchFacet("status", "archived")
    ```
  </TabItem>
</Tabs>

instead of:

<Tabs>
  <TabItem label="Java">
    ```java
    .match("archived", "status")
    ```
  </TabItem>
  <TabItem label="Kotlin">
    ```kotlin
    .match("archived", "status")
    ```
  </TabItem>
</Tabs>

While both achieve the same result, `matchFacet(...)` is generally faster and more efficient.

<Aside type="tip">
Use <code>@Facet</code> on frequently filtered fields (e.g. <code>status</code>, <code>type</code>, <code>category</code>) to take full advantage of this optimization.
</Aside>

---

## Facet statistics

When a field or getter is annotated with `@Facet`, you can also retrieve **facet statistics** — e.g., how many documents
exist per value of a given property.

### Example: Product breakdown by category and brand

<Tabs>
  <TabItem label="Java">
    ```java
    @Searchable
    public record Product(@Facet String category,
                          @Facet String brand,
                          String name,
                          BigDecimal price) {
    }

    List<FacetStats> stats = Fluxzero.search(Product.class)
            .lookAhead("wireless")
            .facetStats();
    ```
  </TabItem>
  <TabItem label="Kotlin">
    ```kotlin
    @Searchable
    data class Product(
        @Facet val category: String,
        @Facet val brand: String,
        val name: String,
        val price: BigDecimal
    )

    val stats: List<FacetStats> = Fluxzero.search(Product::class.java)
        .lookAhead("wireless")
        .facetStats()
    ```
  </TabItem>
</Tabs>

This gives you document counts per facet value:

```json
[
  { "name": "category", "value": "headphones", "count": 55 },
  { "name": "brand", "value": "Acme", "count": 45 },
  { "name": "brand", "value": "NoName", "count": 10 }
]
```

<Aside type="tip">
Use <code>matchFacet("category", "headphones")</code> to filter efficiently by facet value.
</Aside>

Each `FacetStats` object will contain:

- the facet name (e.g., `category`)
- the distinct values (e.g., `"electronics"`, `"clothing"`)
- the number of documents per value

---

---

## Search index exclusion

By default, all non-transient properties of a document are included in the search index. However, you can fine-tune what
fields get indexed using the following annotations:

### `@SearchExclude`

Use `@SearchExclude` to exclude a field or type from search indexing. This prevents the property from being matched in
search queries, though it will still be present in the stored document and accessible at runtime.

<Tabs>
  <TabItem label="Java">
    ```java
    public record Order(String id,
                        Customer customer,
                        @SearchExclude byte[] encryptedPayload) {
    }
    ```
  </TabItem>
  <TabItem label="Kotlin">
    ```kotlin
    data class Order(
        val id: String,
        val customer: Customer,
        @SearchExclude val encryptedPayload: ByteArray
    )
    ```
  </TabItem>
</Tabs>

You can also exclude entire types:

<Tabs>
  <TabItem label="Java">
    ```java
    @SearchExclude
    public record EncryptedData(byte[] value) {
    }
    ```
  </TabItem>
  <TabItem label="Kotlin">
    ```kotlin
    @SearchExclude
    data class EncryptedData(val value: ByteArray)
    ```
  </TabItem>
</Tabs>

In this case, none of the properties of `EncryptedData` will be indexed, unless you override selectively with
`@SearchInclude`.

---

### `@SearchInclude`

Use `@SearchInclude` to **override** an exclusion. This is functionally equivalent to `@SearchExclude(false)` and is
typically used on a field or class that would otherwise be excluded by inheritance or parent-level settings.

<Tabs>
  <TabItem label="Java">
    ```java
    @SearchExclude
    public record BaseDocument(String internalNotes,
                               @SearchInclude String publicSummary) {
    }
    ```
  </TabItem>
  <TabItem label="Kotlin">
    ```kotlin
    @SearchExclude
    data class BaseDocument(
        val internalNotes: String,
        @SearchInclude val publicSummary: String
    )
    ```
  </TabItem>
</Tabs>

Here, `internalNotes` will not be indexed, but `publicSummary` will be.

---

## Behavior summary

| Annotation                                  | Effect                                                           |
|---------------------------------------------|------------------------------------------------------------------|
| `@SearchExclude`                            | Prevents property/type from being indexed for search             |
| `@SearchExclude(false)` or `@SearchInclude` | Explicitly includes a property even if a parent type is excluded |
| *No annotation*                             | Field is included in the search index by default                 |

<Aside type="note">
If you want a field to be completely omitted from storage (not just indexing), mark it as <code>transient</code>, use
<code>@JsonIgnore</code>, or another serialization-related annotation.
</Aside>

---

## Rapid sorting and filtering

To enable efficient **range filters** and **sorted results** in document searches, annotate properties with `@Sortable`:

<Tabs>
  <TabItem label="Java">
    ```java
    public record Product(@Sortable BigDecimal price,
                          @Sortable("releaseDate") Instant publishedAt) {
    }
    ```
  </TabItem>
  <TabItem label="Kotlin">
    ```kotlin
    data class Product(
        @Sortable val price: BigDecimal,
        @Sortable("releaseDate") val publishedAt: Instant
    )
    ```
  </TabItem>
</Tabs>

This tells Fluxzero to pre-index these fields in a lexicographically sortable format. When you issue a search
with a `between()` constraint or `.sort(...)` clause, the Fluxzero Runtime can evaluate it directly in the data store —
without needing to load and compare documents in memory.

### Optimized search example

<Tabs>
  <TabItem label="Java">
    ```java
    List<Product> results = Fluxzero.search(Product.class)
            .between("price", 10, 100)
            .sort("releaseDate")
            .fetch(100);
    ```
  </TabItem>
  <TabItem label="Kotlin">
    ```kotlin
    val results: List<Product> = Fluxzero.search(Product::class.java)
        .between("price", 10, 100)
        .sort("releaseDate")
        .fetch(100)
    ```
  </TabItem>
</Tabs>

<Aside type="caution">
You can always sort by any field — even if it is not <code>@Sortable</code> — but performance will degrade because the sorting happens after all matching documents are loaded.
</Aside>

---

### What gets indexed

Fluxzero normalizes and encodes sortable fields depending on their value type:

| Type           | Behavior                                                                 |
|----------------|--------------------------------------------------------------------------|
| Numbers        | Padded base-10 string (preserves order, supports negatives)              |
| Instants       | ISO-8601 timestamp format                                                |
| Strings/Others | Normalized (lowercased, trimmed, diacritics removed)                     |

This ensures that sorting is consistent and correct across types and locales.

### Nested and composite values

If the sortable field is:

- A **collection** → Max element is indexed. Create a getter if you need sorting on the min element
- A **map** → Values are indexed using `key/propertyName` path
- A **nested object** annotated with `@Sortable` → Its `toString()` is used
- A **POJO with `@Sortable` fields** → Those nested values are indexed with prefixed paths

#### Important notes

- **No retroactive indexing**: Adding `@Sortable` to a field does not automatically reindex existing documents.
- To apply sorting retroactively, trigger a reindex (e.g. with `@HandleDocument` and a bumped `@Revision`).
- Sorting and filtering still happen within the Fluxzero Runtime, but without `@Sortable` the logic falls back
  to in-memory evaluation — which is much slower.

<Aside type="tip">
Use <code>@Sortable</code> together with <code>@Facet</code> if you want both sorting and aggregation/filtering on a field.
</Aside>

---

## Customizing returned fields

When performing a search, you can control which fields are included or excluded in the returned documents.

This is useful for:

- Hiding sensitive fields (e.g. private data, tokens)
- Reducing payload size
- Optimizing performance when only partial data is needed

### Example

Given the following indexed document:

```json
{
  "id": "user123",
  "profile": {
    "name": "Alice",
    "email": "alice@example.com",
    "ssn": "123456789"
  },
  "roles": [
    "user",
    "admin"
  ]
}
```

You can exclude sensitive fields like so:

<Tabs>
  <TabItem label="Java">
    ```java
    Fluxzero.search("users")
         .exclude("profile.ssn")
         .fetch(50);
    ```
  </TabItem>
  <TabItem label="Kotlin">
    ```kotlin
    Fluxzero.search("users")
        .exclude("profile.ssn")
        .fetch(50)
    ```
  </TabItem>
</Tabs>

This will return:

```json
{
  "id": "user123",
  "profile": {
    "name": "Alice",
    "email": "alice@example.com"
  },
  "roles": [
    "user",
    "admin"
  ]
}
```

<Aside type="note">
You can also use <code>.includeOnly(...)</code> instead to explicitly whitelist fields.
</Aside>

---

## Streaming results

Fluxzero supports efficient streaming of large result sets:

<Tabs>
  <TabItem label="Java">
    ```java
    Fluxzero.search("auditTrail")
        .inLast(Duration.ofDays(7))
        .stream().forEach(auditEvent -> process(auditEvent));
    ```
  </TabItem>
  <TabItem label="Kotlin">
    ```kotlin
    Fluxzero.search("auditTrail")
        .inLast(Duration.ofDays(7))
        .stream()
        .forEach { auditEvent -> process(auditEvent) }
    ```
  </TabItem>
</Tabs>

---

## Deleting documents

To remove documents from the index:

<Tabs>
  <TabItem label="Java">
    ```java
    Fluxzero.search("expiredTokens")
        .before(Instant.now())
        .delete();
    ```
  </TabItem>
  <TabItem label="Kotlin">
    ```kotlin
    Fluxzero.search("expiredTokens")
        .before(Instant.now())
        .delete()
    ```
  </TabItem>
</Tabs>

---

## Summary

- Use `Fluxzero.index(...)` to manually index documents.
- Use `@Searchable` to configure the collection name or time range for an object.
- Use `@Aggregate(searchable = true)` or `@Stateful` for automatic indexing.
- Use `Fluxzero.search(...)` to query, stream, sort, and aggregate your documents.