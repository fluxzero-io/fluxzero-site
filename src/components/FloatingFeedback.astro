---
// Floating feedback component that anchors feedback to selected text locations
export interface Props {
  slug?: string;
  className?: string;
}

const { slug, className = '' } = Astro.props;

// Use current page path if no slug provided
const currentSlug = slug || Astro.url.pathname;
const componentId = `floating-feedback-${Math.random().toString(36).substr(2, 9)}`;
---

<div id={componentId} class={`floating-feedback-container ${className}`}>
  <!-- Floating feedback button -->
  <button class="feedback-button" id="feedback-toggle">
    üí¨ <span class="feedback-count">0</span>
  </button>

  <!-- Feedback popup -->
  <div class="feedback-popup-container" id="feedback-popup" style="display: none;">
    <div class="feedback-popup-header">
      <h3>Feedback & Questions</h3>
      <button class="feedback-popup-close">&times;</button>
    </div>
    <div class="feedback-list">
      <!-- Feedback list will be populated here -->
    </div>
  </div>

  <!-- Floating indicators will also be injected into the page -->
</div>

<script define:vars={{ currentSlug, componentId }}>
  class FloatingFeedback {
    constructor(container, slug) {
      this.container = container;
      this.slug = slug;
      this.feedback = null;
      this.indicators = [];
      this.activePopup = null;
      this.isPopupOpen = false;

      this.init();
    }

    async init() {
      await this.fetchFeedback();
      this.processTextSelections();
      this.renderFeedbackList();
      this.setupPopupHandlers();
      this.setupScrollListener();
    }

    async fetchFeedback() {
      try {
        const response = await fetch(`/api/feedback?slug=${encodeURIComponent(this.slug)}`);
        if (!response.ok) {
          throw new Error(`Failed to fetch feedback: ${response.status}`);
        }
        this.feedback = await response.json();
      } catch (err) {
        console.error('Error fetching feedback:', err);
      }
    }

    renderFeedbackList() {
      const feedbackList = this.container.querySelector('.feedback-list');
      const feedbackButton = this.container.querySelector('.feedback-button');
      const feedbackCount = this.container.querySelector('.feedback-count');

      // Update button count
      const count = this.feedback?.discussions?.length || 0;
      feedbackCount.textContent = count;

      // Show/hide button based on feedback availability
      if (count === 0) {
        feedbackButton.style.display = 'none';
        feedbackList.innerHTML = '<p class="no-feedback">No feedback yet for this page.</p>';
        return;
      }

      feedbackButton.style.display = 'block';

      // Sort discussions by date descending (newest first)
      const sortedDiscussions = [...this.feedback.discussions].sort((a, b) =>
        new Date(b.createdAt) - new Date(a.createdAt)
      );

      const listHtml = sortedDiscussions.map((discussion, index) => {
        const cleanTitle = discussion.title.replace(/^\[slug:[^\]]+\]\s*/, '');
        const date = new Date(discussion.createdAt);
        const dateStr = date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
        const timeStr = date.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', hour12: false });

        // Check if there's a corresponding highlighted span on the page
        const hasHighlightedText = !!document.querySelector(`[data-feedback-id="${discussion.id}"]`);
        const externalIcon = hasHighlightedText ? '' : ' ‚ÜóÔ∏è';

        return `
          <div class="feedback-item">
            <a href="${discussion.url}" target="_blank" rel="noopener noreferrer" class="feedback-item-link" data-discussion-id="${discussion.id}">
              <span class="feedback-meta">
                üïê ${dateStr} ${timeStr}${discussion.commentCount > 0 ? ` ‚Ä¢ ${discussion.commentCount}üí¨` : ''}
              </span>
              <span class="feedback-separator">‚Ä¢</span>
              <span class="feedback-title">${cleanTitle}${externalIcon}</span>
            </a>
          </div>
        `;
      }).join('');

      feedbackList.innerHTML = `
        <div class="feedback-items">
          ${listHtml}
        </div>
      `;

      // Add click handlers to scroll to highlighted text
      feedbackList.querySelectorAll('.feedback-item-link').forEach((link) => {
        link.addEventListener('click', (e) => {
          const discussionId = link.dataset.discussionId;
          const highlightSpan = document.querySelector(`[data-feedback-id="${discussionId}"]`);

          if (highlightSpan) {
            e.preventDefault();

            // Scroll to the highlighted text
            highlightSpan.scrollIntoView({
              behavior: 'smooth',
              block: 'center'
            });

            // Find the discussion data and show the popup
            const discussion = this.feedback.discussions.find(d => d.id === discussionId);
            if (discussion) {
              // Find the corresponding indicator
              const indicator = this.indicators.find(ind => ind.discussion.id === discussionId);
              if (indicator) {
                setTimeout(() => {
                  this.showFeedbackPopup(discussion, indicator.element);
                }, 500); // Delay to let scroll animation finish
              }
            }
          }
          // If span doesn't exist, let default behavior happen (open GitHub URL)
        });
      });
    }

    setupPopupHandlers() {
      const feedbackButton = this.container.querySelector('.feedback-button');
      const feedbackPopup = this.container.querySelector('#feedback-popup');
      const closeButton = this.container.querySelector('.feedback-popup-close');

      // Toggle popup when button is clicked
      feedbackButton.addEventListener('click', () => {
        this.isPopupOpen = !this.isPopupOpen;
        feedbackPopup.style.display = this.isPopupOpen ? 'block' : 'none';
      });

      // Close popup when close button is clicked
      closeButton.addEventListener('click', () => {
        this.isPopupOpen = false;
        feedbackPopup.style.display = 'none';
      });

      // Close popup when clicking outside
      document.addEventListener('click', (e) => {
        if (this.isPopupOpen &&
            !feedbackPopup.contains(e.target) &&
            !feedbackButton.contains(e.target)) {
          this.isPopupOpen = false;
          feedbackPopup.style.display = 'none';
        }
      });
    }

    processTextSelections() {
      if (!this.feedback || this.feedback.discussions.length === 0) return;

      this.feedback.discussions.forEach((discussion, index) => {
        const selectedText = this.extractSelectedText(discussion);
        const textLocation = this.findTextInPage(selectedText);

        if (textLocation) {
          this.createFeedbackIndicator(discussion, textLocation, index);
        }
      });
    }

    extractSelectedText(discussion) {
      if (discussion.metadata?.selection?.text) {
        return discussion.metadata.selection.text;
      }

      // Fallback: extract quoted text from body
      const quoteMatch = discussion.body.match(/>\s*([^\n]+)/);
      return quoteMatch?.[1] || null;
    }

    findTextInPage(selectedText) {
      if (!selectedText) return null;

      // Find the text in the page content
      const walker = document.createTreeWalker(
        document.body,
        NodeFilter.SHOW_TEXT,
        {
          acceptNode: function(node) {
            // Skip script and style elements
            const parent = node.parentElement;
            if (parent.tagName === 'SCRIPT' || parent.tagName === 'STYLE') {
              return NodeFilter.FILTER_REJECT;
            }
            return NodeFilter.FILTER_ACCEPT;
          }
        }
      );

      let node;
      while (node = walker.nextNode()) {
        const text = node.textContent;
        const index = text.indexOf(selectedText);

        if (index !== -1) {
          // Found the text, return position info
          const range = document.createRange();
          range.setStart(node, index);
          range.setEnd(node, index + selectedText.length);

          return {
            range,
            rect: range.getBoundingClientRect(),
            element: node.parentElement,
            text: selectedText
          };
        }
      }

      return null;
    }

    createFeedbackIndicator(discussion, textLocation, index) {
      // Wrap the selected text in a span with feedback indicator
      const span = document.createElement('span');
      span.className = 'feedback-highlight';
      span.dataset.feedbackId = discussion.id;
      span.dataset.feedbackIndex = index;

      // Extract the text node content
      const range = textLocation.range;
      const selectedText = range.extractContents();
      span.appendChild(selectedText);

      // Insert the span back
      range.insertNode(span);

      // Create floating indicator
      const indicator = document.createElement('div');
      indicator.className = 'feedback-indicator';
      indicator.innerHTML = `
        <div class="feedback-badge">
          üí¨ ${discussion.commentCount || 0}
        </div>
      `;

      // Position the indicator
      this.updateAbsolutePosition(indicator, span);

      // Add click handler
      indicator.addEventListener('click', (e) => {
        e.preventDefault();
        this.showFeedbackPopup(discussion, indicator);
      });

      // Hide indicator by default
      indicator.style.opacity = '0';
      indicator.style.pointerEvents = 'none';

      let hideTimeout;

      const hideIndicator = () => {
        indicator.style.opacity = '0';
        indicator.style.pointerEvents = 'none';
        indicator.style.transform = 'scale(0.8)';
      };

      const showIndicator = () => {
        clearTimeout(hideTimeout);
        indicator.style.opacity = '0.8';
        indicator.style.pointerEvents = 'auto';
        indicator.style.transform = 'scale(1)';
      };

      const scheduleHide = (delay = 200) => {
        // Don't hide indicator if popup is open
        if (this.activePopup) return;

        clearTimeout(hideTimeout);
        hideTimeout = setTimeout(hideIndicator, delay);
      };

      // Show indicator when hovering over highlighted text
      span.addEventListener('mouseenter', showIndicator);

      // Hide indicator when leaving highlighted text (with delay for moving to indicator)
      span.addEventListener('mouseleave', () => {
        scheduleHide(300); // Give user time to move to indicator
      });

      // Keep indicator visible and enhance when hovering over it
      indicator.addEventListener('mouseenter', () => {
        clearTimeout(hideTimeout);
        indicator.style.opacity = '1';
        indicator.style.transform = 'scale(1.1)';
      });

      // Hide indicator when leaving it
      indicator.addEventListener('mouseleave', () => {
        scheduleHide(100);
      });

      // Add to DOM
      document.body.appendChild(indicator);

      this.indicators.push({
        element: indicator,
        discussion,
        anchor: span
      });
    }



    setupScrollListener() {
      // Use position: absolute instead of fixed for better performance
      this.indicators.forEach(({ element, anchor }) => {
        element.style.position = 'absolute';
        this.updateAbsolutePosition(element, anchor);
      });

      // More responsive scroll handling
      let ticking = false;

      const updatePositions = () => {
        this.indicators.forEach(({ element, anchor }) => {
          this.updateAbsolutePosition(element, anchor);
        });

        // Update popup position if open
        if (this.activePopup && this.activePopup.associatedIndicator) {
          this.updatePopupPosition(this.activePopup, this.activePopup.associatedIndicator);
        }

        ticking = false;
      };

      window.addEventListener('scroll', () => {
        if (!ticking) {
          requestAnimationFrame(updatePositions);
          ticking = true;
        }
      }, { passive: true });

      // Update positions on resize
      window.addEventListener('resize', () => {
        if (!ticking) {
          requestAnimationFrame(updatePositions);
          ticking = true;
        }
      });
    }

    updateAbsolutePosition(indicator, anchor) {
      const rect = anchor.getBoundingClientRect();
      const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
      const scrollLeft = window.pageXOffset || document.documentElement.scrollLeft;

      indicator.style.left = `${rect.right + scrollLeft + 10}px`;
      indicator.style.top = `${rect.top + scrollTop + (rect.height / 2) - 12}px`;
    }

    showFeedbackPopup(discussion, indicator) {
      // Close existing popup
      if (this.activePopup) {
        this.activePopup.remove();
      }

      // Create popup
      const popup = document.createElement('div');
      popup.className = 'feedback-popup';

      const cleanTitle = discussion.title.replace(/^\[slug:[^\]]+\]\s*/, '');

      popup.innerHTML = `
        <div class="feedback-popup-header">
          <h4>${cleanTitle}</h4>
          <button class="feedback-close">&times;</button>
        </div>
        <div class="feedback-popup-content">
          <div class="feedback-author">
            <img src="${discussion.author.avatarUrl}" alt="${discussion.author.login}" width="24" height="24">
            <span>${discussion.author.login}</span>
            <time>${this.formatDate(discussion.createdAt)}</time>
          </div>
          <div class="feedback-selected-text">
            <strong>About:</strong> "${this.extractSelectedText(discussion)}"
          </div>
          <div class="feedback-body">
            ${discussion.body.slice(0, 300)}${discussion.body.length > 300 ? '...' : ''}
          </div>
          <div class="feedback-actions">
            <a href="${discussion.url}" target="_blank" rel="noopener noreferrer">
              View full discussion ‚Üí
            </a>
          </div>
        </div>
      `;

      // Position popup near indicator (fixed position)
      this.updatePopupPosition(popup, indicator);
      popup.style.position = 'fixed';
      popup.style.zIndex = '2000';

      // Store reference for position updates
      popup.associatedIndicator = indicator;

      // Add close handler
      const closePopup = () => {
        popup.remove();
        this.activePopup = null;

        // Hide the indicator when popup closes
        indicator.style.opacity = '0';
        indicator.style.pointerEvents = 'none';
        indicator.style.transform = 'scale(0.8)';
      };

      popup.querySelector('.feedback-close').addEventListener('click', closePopup);

      // Close on click outside (but not on indicator)
      setTimeout(() => {
        const handleOutsideClick = (e) => {
          if (!popup.contains(e.target) && e.target !== indicator && !indicator.contains(e.target)) {
            closePopup();
            document.removeEventListener('click', handleOutsideClick);
          }
        };
        document.addEventListener('click', handleOutsideClick);
      }, 100);

      document.body.appendChild(popup);
      this.activePopup = popup;
    }

    updatePopupPosition(popup, indicator) {
      const indicatorRect = indicator.getBoundingClientRect();
      const popupWidth = 320;

      // Calculate optimal position
      let left = indicatorRect.left;
      let top = indicatorRect.bottom + 10;

      // Ensure popup stays within viewport
      if (left + popupWidth > window.innerWidth) {
        left = window.innerWidth - popupWidth - 10;
      }
      if (left < 10) {
        left = 10;
      }

      // If popup would go below viewport, show above indicator
      if (top + 400 > window.innerHeight) {
        top = indicatorRect.top - 410; // Approximate popup height
      }

      popup.style.left = `${left}px`;
      popup.style.top = `${top}px`;
    }

    formatDate(dateString) {
      return new Date(dateString).toLocaleDateString('en-US', {
        year: 'numeric',
        month: 'short',
        day: 'numeric'
      });
    }
  }

  // Initialize when DOM is ready
  document.addEventListener('DOMContentLoaded', () => {
    const container = document.getElementById(componentId);
    if (container) {
      new FloatingFeedback(container, currentSlug);
    }
  });
</script>

<style>
  .floating-feedback-container {
    position: relative;
  }

  /* Floating feedback button */
  .feedback-button {
    position: fixed;
    bottom: 20px;
    right: 20px;
    background: #1f2937;
    color: white;
    border: 1px solid #374151;
    border-radius: 50px;
    padding: 12px 16px;
    font-size: 14px;
    font-weight: 500;
    cursor: pointer;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.25);
    transition: all 0.3s ease;
    z-index: 1000;
    display: none;
  }

  .feedback-button:hover {
    background: #111827;
    transform: translateY(-2px);
    box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
    border-color: #4b5563;
  }

  .feedback-count {
    margin-left: 6px;
    background: #3b82f6;
    border-radius: 12px;
    padding: 2px 6px;
    font-size: 12px;
    color: white;
    font-weight: 600;
  }

  /* Feedback popup */
  .feedback-popup-container {
    position: fixed;
    bottom: 80px;
    right: 20px;
    width: 350px;
    max-height: 400px;
    background: white;
    border: 1px solid #d1d5db;
    border-radius: 12px;
    box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
    z-index: 1001;
    overflow: hidden;
  }

  .feedback-popup-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 16px 20px;
    background: #f8fafc;
    border-bottom: 1px solid #e2e8f0;
  }

  .feedback-popup-header h3 {
    margin: 0;
    font-size: 16px;
    font-weight: 600;
    color: #1f2937;
  }

  .feedback-popup-close {
    background: none;
    border: none;
    font-size: 20px;
    cursor: pointer;
    color: #64748b;
    padding: 0;
    width: 24px;
    height: 24px;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 4px;
    transition: all 0.2s ease;
  }

  .feedback-popup-close:hover {
    color: #1f2937;
    background: #e2e8f0;
  }

  .feedback-list {
    max-height: 300px;
    overflow-y: auto;
    padding: 8px;
  }

  /* Feedback list styling */
  .feedback-list-title {
    font-size: 1.1rem;
    font-weight: 600;
    color: #1f2937;
    margin: 0 0 0.75rem 0;
    border-bottom: 1px solid #e5e7eb;
    padding-bottom: 0.25rem;
  }

  :global(.feedback-items) {
    display: flex;
    flex-direction: column;
    gap: 0.025rem;
  }

  :global(.feedback-item) {
    background: transparent;
    opacity: 0.7;
    transition: opacity 0.2s ease;
    border: none;
    outline: none;
    box-shadow: none;
  }

  :global(.feedback-item:hover) {
    opacity: 1;
    border: none;
    outline: none;
    box-shadow: none;
  }

  :global(.feedback-item *) {
    border: none;
    outline: none;
    box-shadow: none;
  }

  :global(.feedback-item *:hover) {
    border: none;
    outline: none;
    box-shadow: none;
  }

  :global(.feedback-item *:focus) {
    border: none;
    outline: none;
    box-shadow: none;
  }

  :global(.feedback-item-link) {
    display: flex;
    align-items: center;
    gap: 0.2rem;
    padding: 0.05rem 0.2rem;
    text-decoration: none;
    color: inherit;
    line-height: 1.1;
    border: none;
    outline: none;
    box-shadow: none;
  }

  :global(.feedback-item-link:hover) {
    text-decoration: none;
    border: none;
    outline: none;
    box-shadow: none;
  }

  :global(.feedback-item-link:focus) {
    border: none;
    outline: none;
    box-shadow: none;
  }

  :global(.feedback-item-link:active) {
    border: none;
    outline: none;
    box-shadow: none;
  }

  :global(.feedback-meta) {
    display: flex;
    align-items: center;
    gap: 0.15rem;
    font-size: 10px !important;
    color: #6b7280;
    flex-shrink: 0;
  }

  :global(.feedback-separator) {
    color: #d1d5db;
    font-size: 10px !important;
    margin: 0 0.2rem;
    flex-shrink: 0;
  }

  :global(.feedback-title) {
    color: #3b82f6;
    font-size: 11px !important;
    font-weight: 500;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
    flex: 1;
  }

  .no-feedback {
    color: #6b7280;
    font-style: italic;
    text-align: center;
    padding: 2rem;
    background: #f9fafb;
    border: 1px dashed #d1d5db;
    border-radius: 8px;
  }

  /* Highlighted text styling */
  :global(.feedback-highlight) {
    background: linear-gradient(90deg, transparent 0%, rgba(59, 130, 246, 0.1) 10%, rgba(59, 130, 246, 0.1) 90%, transparent 100%);
    border-bottom: 2px dashed rgba(59, 130, 246, 0.3);
    position: relative;
    cursor: help;
    transition: all 0.2s ease;
  }

  :global(.feedback-highlight:hover) {
    background: linear-gradient(90deg, transparent 0%, rgba(59, 130, 246, 0.2) 10%, rgba(59, 130, 246, 0.2) 90%, transparent 100%);
    border-bottom-color: rgba(59, 130, 246, 0.6);
    box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.1);
  }

  /* Floating indicator */
  :global(.feedback-indicator) {
    position: absolute;
    cursor: pointer;
    transition: opacity 0.2s ease, transform 0.2s ease;
    opacity: 0.7;
    transform: scale(0.8);
    z-index: 1000;
    pointer-events: auto;
  }

  :global(.feedback-badge) {
    background: #3b82f6;
    color: white;
    padding: 4px 8px;
    border-radius: 12px;
    font-size: 12px;
    font-weight: 500;
    white-space: nowrap;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
  }

  :global(.feedback-indicator:hover) {
    opacity: 1 !important;
    transform: scale(1.1) !important;
  }

  /* Popup styling */
  :global(.feedback-popup) {
    background: white;
    border: 1px solid #e5e7eb;
    border-radius: 8px;
    box-shadow: 0 10px 25px rgba(0, 0, 0, 0.15);
    width: 300px;
    max-height: 400px;
    overflow: hidden;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
  }

  :global(.feedback-popup-header) {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 12px 16px;
    background: #f9fafb;
    border-bottom: 1px solid #e5e7eb;
  }

  :global(.feedback-popup-header h4) {
    margin: 0;
    font-size: 14px;
    font-weight: 600;
    color: #1f2937;
    flex: 1;
    margin-right: 12px;
  }

  :global(.feedback-close) {
    background: none;
    border: none;
    font-size: 18px;
    cursor: pointer;
    color: #6b7280;
    padding: 0;
    width: 20px;
    height: 20px;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  :global(.feedback-close:hover) {
    color: #1f2937;
  }

  :global(.feedback-popup-content) {
    padding: 16px;
  }

  :global(.feedback-author) {
    display: flex;
    align-items: center;
    gap: 8px;
    margin-bottom: 12px;
    font-size: 12px;
    color: #6b7280;
  }

  :global(.feedback-author img) {
    border-radius: 50%;
    border: 1px solid #e5e7eb;
  }

  :global(.feedback-author span) {
    font-weight: 500;
    color: #1f2937;
  }

  :global(.feedback-selected-text) {
    background: #f3f4f6;
    border-left: 3px solid #3b82f6;
    padding: 8px 12px;
    margin: 12px 0;
    border-radius: 0 4px 4px 0;
    font-size: 12px;
    color: #4b5563;
    font-style: italic;
  }

  :global(.feedback-body) {
    font-size: 13px;
    line-height: 1.5;
    color: #1f2937;
    margin-bottom: 12px;
  }

  :global(.feedback-actions a) {
    color: #3b82f6;
    text-decoration: none;
    font-size: 12px;
    font-weight: 500;
  }

  :global(.feedback-actions a:hover) {
    text-decoration: underline;
  }

  /* Dark mode support */
  @media (prefers-color-scheme: dark) {
    .feedback-button {
      background: #374151;
      border-color: #4b5563;
    }

    .feedback-button:hover {
      background: #4b5563;
      border-color: #6b7280;
    }

    .feedback-popup-container {
      background: #1f2937;
      border-color: #374151;
    }

    .feedback-popup-header {
      background: #111827;
      border-color: #374151;
    }

    .feedback-popup-header h3 {
      color: #f9fafb;
    }

    .feedback-popup-close {
      color: #9ca3af;
    }

    .feedback-popup-close:hover {
      color: #f9fafb;
      background: #374151;
    }

    .feedback-list-title {
      color: #f9fafb;
      border-color: #374151;
    }

    .feedback-item:hover {
      background: #374151;
    }

    .no-feedback {
      background: #1f2937;
      border-color: #374151;
      color: #9ca3af;
    }

    :global(.feedback-popup) {
      background: #1f2937;
      border-color: #374151;
      color: #f9fafb;
    }

    :global(.feedback-popup-header) {
      background: #111827;
      border-color: #374151;
    }

    :global(.feedback-popup-header h4) {
      color: #f9fafb;
    }

    :global(.feedback-selected-text) {
      background: #374151;
      color: #d1d5db;
    }

    :global(.feedback-body) {
      color: #f9fafb;
    }
  }
</style>