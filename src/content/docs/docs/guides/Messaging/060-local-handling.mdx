---
title: Local handling
description: Local handling
slug: docs/guides/messaging/local-handling
sidebar:
   order: 60
---

import { Tabs, TabItem } from '@astrojs/starlight/components';
import { Aside } from '@astrojs/starlight/components';

Fluxzero supports both asynchronous and local (synchronous) message handling. **Local handlers** process messages in the same thread that published them, bypassing the message dispatch infrastructure entirely. This typically results in faster response times and is ideal for simple or time-sensitive use cases.

To define a local handler, annotate the handler method, class, or its enclosing package with `@LocalHandler`:

<Tabs>
<TabItem value="Java" label="Java">

```java
@LocalHandler(logMetrics = true)
public class SomeLocalHandler {
    @HandleEvent
    void handle(ApplicationStarted event) {
        // do something
    }
}
```

</TabItem>
<TabItem value="Kotlin" label="Kotlin">

```kotlin
@LocalHandler(logMetrics = true)
class SomeLocalHandler {
    @HandleEvent
    fun handle(event: ApplicationStarted) {
        // do something
    }
}
```

</TabItem>
</Tabs>

<Aside type="tip">
  By default, handler metrics are disabled for local handlers. To enable, use <code>logMetrics = true</code> to track performance metrics even for local handlers.
</Aside>

## Self-handling messages

Instead of defining message handlers externally, you can embed handler logic directly in the message payload. This is often useful for queries or simple commands.

<Tabs>
<TabItem value="Java" label="Java">

```java
public class GetUserProfile {
    String userId;

    @HandleQuery
    UserProfile handle() {
        // fetch the user profile and return
    }
}
```

</TabItem>
<TabItem value="Kotlin" label="Kotlin">

```kotlin
class GetUserProfile(val userId: String) {

    @HandleQuery
    fun handle(): UserProfile {
        // fetch the user profile and return
    }
}
```

</TabItem>
</Tabs>

By default, such handlers are treated as local. To process them asynchronously (i.e., as part of a consumer), annotate the class with `@TrackSelf`:

<Tabs>
<TabItem value="Java" label="Java">

```java
@TrackSelf
@Consumer(name = "user-management")
public class GetUserProfile {
    String userId;

    @HandleQuery
    UserProfile handle() {
        // async handler
    }
}
```

</TabItem>
<TabItem value="Kotlin" label="Kotlin">

```kotlin
@TrackSelf
@Consumer(name = "user-management")
class GetUserProfile(val userId: String) {

    @HandleQuery
    fun handle(): UserProfile {
        // async handler
    }
}
```

</TabItem>
</Tabs>

When component-scanned (e.g., via Spring), `@TrackSelf` classes will be automatically discovered and registered. This works even if the annotation is placed on an interface rather than the concrete classâ€”allowing for reusable handler patterns.

For example, a generic command handler interface can be tracked and reused:

<Tabs>
<TabItem value="Java" label="Java">

```java
@TrackSelf
public interface UserUpdate {
    @HandleCommand
    default void handle() {
        // default behavior
    }
}
```

</TabItem>
<TabItem value="Kotlin" label="Kotlin">

```kotlin
@TrackSelf
interface UserUpdate {
    @HandleCommand
    fun handle() {
        // default behavior
    }
}
```

</TabItem>
</Tabs>

Implementations of this interface will then be handled asynchronously, using the configured consumer (or the default one if unspecified).