---
title: Sending messages
sidebar:
  order: 100
---

import { Tabs, TabItem } from '@astrojs/starlight/components';
import { Aside } from '@astrojs/starlight/components';

Fluxzero provides a unified way to send all types of messages — **commands**, **events**, **queries**, **schedules**, **web requests**, **metrics**, and more.

All messages are routed through the same infrastructure, with built-in support for:

- **Location transparency** — handlers may run locally or remotely, but behave the same
- **Dispatch interceptors** — for enriching, logging, suppressing, or validating messages
- **Local-first handling** — handlers in the current process are invoked directly
- **Automatic forwarding** to the Fluxzero Runtime if no local handler is present
- **Serialization and correlation** — all messages carry metadata for tracing, retries, and audit

---

## Sending a message

The simplest way to send messages is via static methods on the `Fluxzero` class:

<Tabs>
<TabItem value="Java" label="Java">

```java
Fluxzero.sendCommand(new CreateUser("Alice")); // Async command
Fluxzero.queryAndWait(new GetUser("user-123")); // Blocking query
Fluxzero.publishEvent(new UserSignedUp(...)); // Fire-and-forget event
Fluxzero.schedule(new RetryPayment(...), Duration.ofMinutes(5)); // Delayed schedule
```

</TabItem>
<TabItem value="Kotlin" label="Kotlin">

```kotlin
Fluxzero.sendCommand(CreateUser("Alice"))
Fluxzero.queryAndWait(GetUser("user-123"))
Fluxzero.publishEvent(UserSignedUp(...))
Fluxzero.schedule(RetryPayment(...), Duration.ofMinutes(5))
```

</TabItem>
</Tabs>

Messages can include metadata:

```java
Fluxzero.sendCommand(new CreateUser("Bob"),
                     Metadata.of("source", "admin-ui"));
```

<Aside type="tip">
  Messages are not addressed to specific destinations. Fluxzero handles routing based on message type, not location.
</Aside>

---

## Commands

Commands trigger domain behavior and optionally return a result.

**Fire-and-forget:**

```java
Fluxzero.sendAndForgetCommand(new CreateUser("Alice"));
```

**Send and wait:**

```java
UserId id = Fluxzero.sendCommandAndWait(new CreateUser("Charlie"));
```

**Async:**

```java
CompletableFuture<UserId> future =
    Fluxzero.sendCommand(new CreateUser("Bob"));
```

---

## Queries

Queries retrieve state from read models or projections.

**Blocking:**

```java
UserProfile profile =
    Fluxzero.queryAndWait(new GetUserProfile("user456"));
```

**Async:**

```java
CompletableFuture<UserProfile> result =
    Fluxzero.query(new GetUserProfile("user123"));
```

---

## Events

Events can be published via:

```java
Fluxzero.publishEvent(new UserLoggedIn("user789"));
```

By default:

- ✅ Events are **persisted** in the event log for downstream processing.
- ⚠️ If a **local handler exists**, the event will not be forwarded unless `@LocalHandler(logMessage = true)`.

<Aside type="tip">
  To publish an event for an entity, use <code>entity.apply(...)</code>. This ensures the event is conditionally logged and published according to entity configuration.
</Aside>

---

## Schedules

Schedule messages for future delivery:

```java
Fluxzero.schedule(new ReminderFired(), Duration.ofMinutes(5));
```

Schedule periodic tasks:

```java
Fluxzero.schedulePeriodic(new PollExternalApi());
```

---

## Web requests

Send outbound HTTP calls through the Fluxzero Runtime:

```java
WebRequest request = WebRequest
    .get("https://api.example.com/data").build();
WebResponse response = Fluxzero.get()
    .webRequestGateway().sendAndWait(request);
```

---

## Metrics

Send custom metric messages:

```java
Fluxzero.publishMetrics(
    new SystemLoadMetric(cpu, memory));
```

---

## What happens after dispatch?

Fluxzero processes the message through the following pipeline:

### 1. Pre-serialization dispatch interceptors

All configured `DispatchInterceptor`s run first. They may:

- Inject or modify metadata
- Validate or mutate the message
- Block or suppress delivery

### 2. Local handlers

If a local handler matches the message type/topic, it’s invoked immediately. Otherwise, the message is forwarded.

<Aside type="tip">
  Local handlers with <code>@LocalHandler(logMessage = true)</code> allow messages to be both handled and forwarded.
</Aside>

### 3. Serialization

The message is serialized (typically via Jackson), tagged with metadata, and versioned for transport.

### 4. Post-serialization interceptors

A second pass of interceptors may adjust or enrich the serialized form before sending.

### 5. Runtime forwarding

Messages not handled locally are published to the Fluxzero Runtime. From there, delivery guarantees, retries, rate limits, and remote handler routing apply.

---

## Request timeouts

Apply `@Timeout` to a payload class (command or query) to enforce maximum wait time for blocking calls:

```java
@Timeout(value = 3, timeUnit = TimeUnit.SECONDS)
public record CalculatePremium(UserProfile profile)
    implements Request<BigDecimal> {}
```

When sent using `queryAndWait(...)`, this timeout is respected:

```java
BigDecimal result = Fluxzero
    .queryAndWait(new CalculatePremium(user));
```

If no response arrives in time, a `TimeoutException` is thrown.

<Aside type="tip">
  Asynchronous requests like <code>send(...)</code> don’t enforce timeouts automatically. Use <code>orTimeout(...)</code> on the returned `CompletableFuture` if needed.
</Aside>