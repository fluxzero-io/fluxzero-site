---
title: "Create a New Project"
description: Generate a new Fluxzero project with our interactive project generator
sidebar:
   order: 20
tableOfContents: false
---


### See Fluxzero in action

<YouTube/>

import { Tabs, TabItem, Steps } from '@astrojs/starlight/components';
import ProjectGenerator from '../../../../components/ProjectGenerator.astro';

# Create a New Project

The easiest way to get started with Fluxzero is to generate a new project using our interactive project generator. Choose from several pre-configured templates that include common patterns and best practices.

## Interactive Project Generator

Use the generator below to create a new Fluxzero project tailored to your needs:

<ProjectGenerator />

## Available Templates

### Basic Starter
Perfect for learning Fluxzero fundamentals or building simple applications. Includes:
- Single aggregate example
- Basic command and event handling
- Simple validation patterns
- Getting started documentation

### Smart Home
Ideal for IoT and home automation applications. Features:
- Device management aggregates
- Room-based organization
- Sensor data handling
- Automation rule engine
- WebSocket integration for real-time updates

### E-commerce
Complete foundation for online stores and marketplaces. Includes:
- Product catalog management
- Order processing workflows
- Inventory tracking
- Payment integration patterns
- Customer management

### Microservices
Advanced template for distributed systems. Provides:
- Multiple service boundaries
- Inter-service communication patterns
- Distributed event handling
- API gateway configuration
- Service discovery setup

## Next Steps

After generating your project:

<Steps>
1. **Extract** the downloaded ZIP file to your desired location
2. **Navigate** to the project directory in your terminal
3. **Install dependencies** using your preferred package manager:
   ```bash
   ./mvnw install  # Maven
   # or
   ./gradlew build # Gradle
   ```
4. **Start the development server**:
   ```bash
   ./mvnw spring-boot:run  # Maven
   # or
   ./gradlew bootRun       # Gradle
   ```
5. **Open your browser** to `http://localhost:8080` to see your application
</Steps>

## Manual Project Setup

If you prefer to set up a project manually, you can also:

<Tabs>
<TabItem label="Maven">
```bash
mvn archetype:generate \
  -DgroupId=com.example \
  -DartifactId=my-fluxzero-app \
  -DarchetypeArtifactId=fluxzero-starter-archetype \
  -DarchetypeGroupId=io.fluxzero
```
</TabItem>
<TabItem label="Gradle">
```bash
mkdir my-fluxzero-app
cd my-fluxzero-app
gradle init --type java-application
# Add Fluxzero dependencies to build.gradle
```
</TabItem>
</Tabs>

## Troubleshooting

If you encounter issues:

- **Download doesn't start**: Check that you've filled in both the project name and selected a template
- **Build fails**: Ensure you have Java 17+ installed and configured
- **Port already in use**: Change the server port in `application.properties`

For more help, check our [FAQ](/docs/about/faq) or join our community discussions.


---

## Fluxzero components

In the diagram below, you can see the main components of a Fluxzero application and how they interact with each other.

<Image src={simpleArchitecture} alt="Architecture diagram" class={"dark:bg-white"}
       style={"background-color: var(--sl-color-gray-4);"}/>


- **Centralized orchestration via the Fluxzero Server**
The server is the brain of the system: it handles message routing, storage, indexing for search, scheduling, and autoscaling.

- **No direct HTTP exposure**
Applications don’t expose HTTP endpoints themselves. All external traffic flows through the **Fluxzero Proxy**, which handles authentication, rate limiting, and routing.

- **External HTTP integration via proxy**
Outgoing calls to third-party APIs also pass through the proxy.
[Why this is a good idea →](../concepts/proxy-routing)


- **Persistent WebSocket connections**
Fluxzero clients connect to the server via WebSockets, enabling real-time bi-directional communication at scale.


## Message-driven development

Fluxzero applications use three types of messages:

- **Commands** → Make something happen (`CreateOrder`, `UpdateUser`)
- **Queries** → Get data (`GetOrderHistory`, `FindUsers`)
- **Events** → Something happened (`OrderCreated`, `UserRegistered`)

Every feature you build follows this pattern. Instead of learning different frameworks for HTTP routing, background jobs, webhooks, and event handling, you write message handlers.

For example, to send a welcome email when someone registers:

```java
@HandleEvent
public void sendWelcomeEmail(UserRegistered event) {
    emailService.send(event.userEmail(), "Welcome!");
}
```

This approach keeps code predictable and reduces the variety of patterns you need to remember.

---

## Comparison with traditional stacks

| Task | Traditional approach | With Fluxzero |
|------|---------------------|---------------|
| **New project setup** | Configure databases, message queues, HTTP framework | Run one command, start coding |
| **Add API endpoint** | Route, controller, validation, serialization | Write message handler |
| **Background job** | Set up job queue, workers | Handle command or event |
| **Full-text search** | Integrate search engine | Built-in, works automatically |
| **Testing** | Mock databases, HTTP clients, queues | Test pure functions |
| **Audit trail** | Custom logging implementation | Automatic for all messages |

The main difference is that Fluxzero provides infrastructure as a service, so you spend more time on application code.

## Server requirements

- Java 21 or higher
- PostgreSQL 15 or higher

---

<Aside type="tip">
    Fluxzero is open source. [Explore the code on GitHub](https://github.com/flux-capacitor-io/flux-capacitor-client),
    or get started with our managed service in minutes.
</Aside>





## Everyday actions in Fluxzero

These are some of the most common actions you’ll perform in a Fluxzero app. The Fluxzero runtime does the heavy lifting to make this work fast and reliably:

<table>
    <thead>
    <tr>
        <th style={{ width: "170px" }}>Action</th>
        <th style={{ width: "auto" }}>Description</th>
        <th style={{ width: "270px" }}>Example</th>
    </tr>
    </thead>
    <tbody>
    <tr>
        <td><strong>Send messages</strong></td>
        <td>Dispatch a message to be handled anywhere</td>
        <td><code>sendCommand(new BuyItem(...))</code></td>
    </tr>
    <tr>
        <td><strong>Load entities</strong></td>
        <td>Get the current state of a persisted object</td>
        <td><code>loadEntity(accountId)</code></td>
    </tr>
    <tr>
        <td><strong>Schedule actions</strong></td>
        <td>Trigger a message at a future time</td>
        <td><code>schedule(email, ofMinutes(5))</code></td>
    </tr>
    <tr>
        <td><strong>Search documents</strong></td>
        <td>Full-text search over indexed data</td>
        <td><code>search("items").match("apple")</code></td>
    </tr>
    <tr>
        <td><strong>Call HTTP APIs</strong></td>
        <td>Make outbound HTTP requests</td>
        <td><code>sendWebRequest(post(...))</code></td>
    </tr>
    </tbody>
</table>

These are the actions you’ll use in most apps — but Fluxzero can do a lot more.

From long-running workflows and upcasting to content filtering and multi-tenant access control, advanced topics are covered in later guides.