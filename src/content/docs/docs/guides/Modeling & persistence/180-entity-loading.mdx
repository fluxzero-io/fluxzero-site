---
title: Entity loading
sidebar:
  order: 180
---

import { Aside, Tabs, TabItem } from '@astrojs/starlight/components';

To change the state of an entity, use `Fluxzero.loadAggregate(...)` to retrieve the aggregate and apply updates to it.

Here’s a basic example of a command handler applying a `CreateUser` update:

<Tabs>
  <TabItem label="Java">

```java
public class UserCommandHandler {
    @HandleCommand
    void handle(CreateUser command) {
        Fluxzero.loadAggregate(command.getUserId()).assertAndApply(command);
    }
}
```

  </TabItem>
  <TabItem label="Kotlin">

```kotlin
class UserCommandHandler {
    @HandleCommand
    fun handle(command: CreateUser) {
        Fluxzero.loadAggregate(command.userId).assertAndApply(command)
    }
}
```

  </TabItem>
</Tabs>

This loads the `UserAccount` entity by ID and applies the `CreateUser` command. Internally, Fluxzero will:

1. **Rehydrate** the entity using stored events or snapshots
2. **Run all @AssertLegal methods** to verify preconditions
3. **Call the @Apply method** to produce a new entity state
4. **Persist the event** in the aggregate event log (if event sourcing is active)
5. **Publish a domain event** (using the applied payload, unless overridden)

<Aside type="note">
When loading an event-sourced <code>Entity</code> inside a message handler, Fluxzero automatically replays the entity up to the time of the handled message — not to the present.
This ensures you always see the entity state as it was when the message occurred, even if later updates exist.
</Aside>

The `assertAndApply()` call is equivalent to this two-step sequence:

<Tabs>
  <TabItem label="Java">

```java
.aggregate(...)
  .assertLegal(update)
  .apply(update);
```

  </TabItem>
  <TabItem label="Kotlin">

```kotlin
.aggregate(...)
  .assertLegal(update)
  .apply(update)
```

  </TabItem>
</Tabs>

<Aside type="tip">
Using `assertAndApply()` ensures validation always precedes state changes and event publication.
</Aside>