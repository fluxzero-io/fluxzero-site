---
title: Model persistence
sidebar:
   order: 200
---

import { Tabs, TabItem } from '@astrojs/starlight/components';
import { Aside } from '@astrojs/starlight/components';

Fluxzero supports multiple strategies for storing and reloading aggregates:

- **Event sourcing**: state is derived by replaying a stream of applied updates (events)
- **Document storage**: the full aggregate is stored as a document
- **In-memory only**: ephemeral state, not persisted across messages

By default, aggregates use **event sourcing** (`@Aggregate(eventSourced = true)`), but you can configure each aggregate individually.

---

## Event sourcing

Event-sourced aggregates are reconstructed from their event history. When you load an aggregate (via `loadAggregate(...)`, `loadEntity(...)`, or `loadAggregateFor(...)`), Fluxzero restores its current state by:

- Using the cache, if enabled (default).
- If snapshotting is enabled and a snapshot exists, using it as a starting point, then replaying any subsequent events.
- Otherwise, rehydrating the entire state from the event history, replaying each past event through its matching `@Apply` method.

Each event is deserialized and routed to the corresponding `@Apply` method to reconstruct the aggregate’s entity graph.

- If no such method exists for a given event, the event is silently ignored.
- If the event class itself is missing, deserialization will fail unless `ignoreUnknownEvents = true` is set on the aggregate. For better handling, see *Upcasting*.

---

### Loading an aggregate

Fluxzero resolves the current state of an aggregate or entity using the strategy described above.

---

### Applying updates and committing changes

Once an aggregate has been loaded, you can apply updates using `Entity#apply(...)`. Each update follows this lifecycle:

1. The state transition is computed using an `@Apply` method (on the update or entity).
2. The update is stored in the event store and optionally published (depending on publication settings).
3. The new state is written back to the aggregate cache (if enabled).
4. A new snapshot is created if a snapshot threshold has been reached.

<Aside type="note">
<strong>Commit timing:</strong>
By default, updates are committed only after the current message batch completes, not immediately. This means:
- Updates are locally cached (per tracker thread) until the batch is confirmed.
- This avoids unnecessary round-trips to the Fluxzero runtime during batch processing.

You can change this behavior by committing explicitly at the end of a handler method.
</Aside>

### Persistence behavior

You can customize event persistence behavior with:

- `eventPublication`: prevent events when nothing has changed
- `publicationStrategy`: store-only vs publish-and-store
- `snapshotPeriod`: replace snapshot after every N updates
- `ignoreUnknownEvents`: handle versioned aggregates gracefully

<Tabs>
  <TabItem label="Java">
    ```java
    @Aggregate(snapshotPeriod = 1000)
    public record UserAccount(@EntityId UserId userId,
                              UserProfile profile) {

        @Apply
        UserAccount apply(UpdateProfile update) {
            return toBuilder().profile(update.getProfile()).build();
        }
    }
    ```
  </TabItem>
  <TabItem label="Kotlin">
    ```kotlin
    @Aggregate(snapshotPeriod = 1000)
    data class UserAccount(
        @EntityId val userId: UserId,
        val profile: UserProfile
    ) {
        @Apply
        fun apply(update: UpdateProfile): UserAccount {
            return copy(profile = update.profile)
        }
    }
    ```
  </TabItem>
</Tabs>

---

## Document storage

Fluxzero can also store aggregates as documents in a searchable document store. This is useful for:

- Read-heavy aggregates
- Aggregates with large histories
- Reference models that don’t need event streams

To enable document storage, set `searchable = true` in the `@Aggregate` annotation:

<Tabs>
  <TabItem label="Java">
    ```java
    @Aggregate(eventSourced = false, searchable = true, collection = "countries")
    public record Country(@EntityId String countryCode,
                          String name) {
    }
    ```
  </TabItem>
  <TabItem label="Kotlin">
    ```kotlin
    @Aggregate(eventSourced = false, searchable = true, collection = "countries")
    data class Country(
        @EntityId val countryCode: String,
        val name: String
    )
    ```
  </TabItem>
</Tabs>

The entity can still use:

- `@InterceptApply` to block or modify updates
- `@AssertLegal` to validate updates
- `@Apply` to compute and update state

Each applied update overwrites the document in the store and, by default, is also published as an event. If you want to disable event publication, use `@Aggregate(eventPublication = NEVER)`.

<Aside type="caution">
If you disable event publication, also disable caching — otherwise you risk inconsistent state between application instances.
</Aside>

<Aside type="note">
The `collection` defaults to the simple class name of the aggregate. You can also configure time-range indexing with `timestampPath` and `endPath` for temporal queries.
</Aside>

<Aside type="caution">
If you set `eventSourced = false` and do not enable `searchable`, the aggregate will not be persisted. Its state will only live in memory during message processing — not recommended unless for purely transient behavior.
</Aside>

---

## Dual persistence

You can combine both strategies by enabling `eventSourced = true` and `searchable = true`.

Fluxzero will:

- Store events for replay and auditing
- Index the latest version as a document for fast retrieval and search

<Tabs>
  <TabItem label="Java">
    ```java
    @Aggregate(searchable = true)
    public record Order(@EntityId OrderId orderId,
                        OrderDetails details) {
    }
    ```
  </TabItem>
  <TabItem label="Kotlin">
    ```kotlin
    @Aggregate(searchable = true)
    data class Order(
        @EntityId val orderId: OrderId,
        val details: OrderDetails
    )
    ```
  </TabItem>
</Tabs>

This hybrid approach is ideal when you need both traceability and query speed.

---

## Caching and checkpoints

Fluxzero automatically caches aggregates after loading or applying updates (unless `cached = false`). This enables:

- Fast reuse of recently loaded aggregates
- Automatic rehydration from snapshots or partial checkpoints (when configured)

You can tune cache behavior with:

- `cached`: disable shared cache
- `cachingDepth`: how many versions to retain (enables `.previous()` access)
- `checkpointPeriod`: how often to insert intermediate checkpoints

<Aside type="note">
  When loading an aggregate inside an event handler, Fluxzero guarantees that the returned entity is up-to-date. If the event being handled belongs to that aggregate, it is rehydrated *up to and including* that event. Fluxzero will wait, if needed, until the cache has caught up, preventing stale reads and ensuring consistency.
</Aside>

This makes it possible to write event-sourced, state-aware logic directly within event handlers — often eliminating the need for separate projections or read models.

### Example: detecting significant balance change

<Tabs>
  <TabItem label="Java">
    ```java
    public class FraudMonitor {

        @HandleEvent
        void handle(Entity<BankAccount> entity) {
            BankAccount current = entity.get();
            BankAccount previous = entity.previous().get();

            if (hasSuspiciousDelta(previous, current)) {
                Fluxzero.publishEvent(new AdminNotification(
                        "Unusual balance change on account %s"
                                .formatted(current.getAccountId())));
            }
        }

        boolean hasSuspiciousDelta(BankAccount previous, BankAccount current) {
            if (previous == null || current == null) {
                return false;
            }
            BigDecimal delta = current.getBalance()
                    .subtract(previous.getBalance()).abs();
            return delta.compareTo(BigDecimal.valueOf(10_000)) > 0;
        }
    }
    ```
  </TabItem>
  <TabItem label="Kotlin">
    ```kotlin
    class FraudMonitor {

        @HandleEvent
        fun handle(entity: Entity<BankAccount>) {
            val current = entity.get()
            val previous = entity.previous().get()

            if (hasSuspiciousDelta(previous, current)) {
                Fluxzero.publishEvent(
                    AdminNotification(
                        "Unusual balance change on account ${current.accountId}"
                    )
                )
            }
        }

        fun hasSuspiciousDelta(previous: BankAccount?, current: BankAccount?): Boolean {
            if (previous == null || current == null) return false
            val delta = current.balance.subtract(previous.balance).abs()
            return delta > BigDecimal.valueOf(10_000)
        }
    }
    ```
  </TabItem>
</Tabs>

In this example:

- The aggregate (`BankAccount`) is automatically loaded in sync with the current event.
- The handler has access to both the current and previous state.
- It uses this to detect significant balance changes.
- No external store or manual query is needed — this is pure, consistent, event-sourced state.