---
title: Message handling
description: Message handling
slug: docs/guides/messaging/message-handling
sidebar:
  order: 20
---

import { Aside, Tabs, TabItem } from '@astrojs/starlight/components';

Fluxzero is centered around sending and receiving messages — such as **commands**, **events**, **queries**, and **web requests**. These messages can originate from your own application or any other client connected to the same Fluxzero Runtime.

Handlers are simply methods annotated with `@HandleCommand`, `@HandleEvent`, `@HandleQuery`, etc. Here’s a basic example of an event handler that dispatches a command to send a welcome email when a user is created:

<Tabs>
<TabItem value="Java" label="Java">

```java
class UserEventHandler {
    @HandleEvent
    void handle(CreateUser event) {
        Fluxzero.sendCommand(new SendWelcomeEmail(event.getUserProfile()));
    }
}
```

</TabItem>
<TabItem value="Kotlin" label="Kotlin">

```kotlin
class UserEventHandler {
    @HandleEvent
    fun handle(event: CreateUser) {
        Fluxzero.sendCommand(SendWelcomeEmail(event.userProfile))
    }
}
```

</TabItem>
</Tabs>

This handler uses the static `sendCommand` method on Fluxzero, which works because the client is automatically injected into the thread-local context before message handling begins. This eliminates the need to inject `Fluxzero` into every handler.

---

To receive that command, define a corresponding command handler:

<Tabs>
<TabItem value="Java" label="Java">

```java
class EmailCommandHandler {
    @HandleCommand
    void handle(SendWelcomeEmail command) {
        // send welcome email to user
    }
}
```

</TabItem>
<TabItem value="Kotlin" label="Kotlin">

```kotlin
class EmailCommandHandler {
    @HandleCommand
    fun handle(command: SendWelcomeEmail) {
        // send welcome email to user
    }
}
```

</TabItem>
</Tabs>

Handlers can return a result (e.g., from queries or commands). The result is automatically published as a **Result** message and sent back to the originating client:

<Tabs>
<TabItem value="Java" label="Java">

```java
class UserQueryHandler {
    @HandleQuery
    UserProfile handle(GetUserProfile query) {
        // return the user profile
        return new UserProfile(...);
    }
}
```

</TabItem>
<TabItem value="Kotlin" label="Kotlin">

```kotlin
class UserQueryHandler {
    @HandleQuery
    fun handle(query: GetUserProfile): UserProfile {
        // return the user profile
        return UserProfile(...)
    }
}
```

</TabItem>
</Tabs>

To perform a query and wait synchronously for its result:

<Tabs>
<TabItem value="Java" label="Java">

```java
class PasswordEventHandler {
    @HandleEvent
    void handle(ResetPassword event) {
        UserProfile user = Fluxzero.queryAndWait(new GetUserProfile(event.getUserId()));
        // perform reset using user
    }
}
```

</TabItem>
<TabItem value="Kotlin" label="Kotlin">

```kotlin
class PasswordEventHandler {
    @HandleEvent
    fun handle(event: ResetPassword) {
        val user = Fluxzero.queryAndWait(GetUserProfile(event.userId))
        // perform reset using user
    }
}
```

</TabItem>
</Tabs>

## Returning futures

Handler methods may also return a `CompletableFuture<T>` instead of a direct value. Fluxzero will publish the result when the future completes:

<Tabs>
<TabItem value="Java" label="Java">

```java
class AsyncUserQueryHandler {
    @HandleQuery
    CompletableFuture<UserProfile> handle(GetUserProfile query) {
        return userService.fetchAsync(query.getUserId());
    }
}
```

</TabItem>
<TabItem value="Kotlin" label="Kotlin">

```kotlin
class AsyncUserQueryHandler {
    @HandleQuery
    fun handle(query: GetUserProfile): java.util.concurrent.CompletableFuture<UserProfile> {
        return userService.fetchAsync(query.userId)
    }
}
```

</TabItem>
</Tabs>

<Aside type="caution">
    Returning a future means Fluxzero considers the message *handled* when the future is returned, not when it completes. For business-critical flows, prefer synchronous returns (or `join()` explicitly) to keep back-pressure and acknowledgment semantics straightforward.
</Aside>

## Handler matching & passive handlers

Fluxzero resolves which handler(s) should run based on **message type** and **specificity**.

### Most specific handler wins (per class)

If multiple methods in the *same class* match a message, only the most specific one is invoked.

<Tabs>
<TabItem value="Java" label="Java">

```java
class SpecificityExample {
    @HandleEvent
    void handle(Object event) { /* generic fallback */ }

    @HandleEvent
    void handle(CreateUser event) { /* specific handler */ }
}
```

</TabItem>
<TabItem value="Kotlin" label="Kotlin">

```kotlin
class SpecificityExample {
    @HandleEvent
    fun handle(event: Any) { /* generic fallback */ }

    @HandleEvent
    fun handle(event: CreateUser) { /* specific handler */ }
}
```

</TabItem>
</Tabs>

### Multiple classes are all invoked (for events)

When different classes handle the same **event**, each eligible handler runs independently.

<Tabs>
<TabItem value="Java" label="Java">

```java
class BusinessHandler {
    @HandleEvent
    void handle(CreateUser event) { /* business logic */ }
}

class LoggingHandler {
    @HandleEvent
    void log(Object event) { /* audit/metrics */ }
}
```

</TabItem>
<TabItem value="Kotlin" label="Kotlin">

```kotlin
class BusinessHandler {
    @HandleEvent
    fun handle(event: CreateUser) { /* business logic */ }
}

class LoggingHandler {
    @HandleEvent
    fun log(event: Any) { /* audit/metrics */ }
}
```

</TabItem>
</Tabs>

### Requests prefer a single active handler

For **commands**, **queries**, and **web requests**, a single non-passive handler should produce the response. Additional passive handlers can observe for metrics/auditing.

<Tabs>
<TabItem value="Java" label="Java">

```java
class UserHandler {
    @HandleQuery
    UserAccount handle(GetUser query) {
        return userRepository.find(query.getUserId());
    }
}

class QueryMetricsHandler {
    @HandleQuery(passive = true)
    void record(Object query) {
        metrics.increment("queries." + query.getClass().getSimpleName());
    }
}
```

</TabItem>
<TabItem value="Kotlin" label="Kotlin">

```kotlin
class UserHandler {
    @HandleQuery
    fun handle(query: GetUser): UserAccount {
        return userRepository.find(query.userId)
    }
}

class QueryMetricsHandler {
    @HandleQuery(passive = true)
    fun record(query: Any) {
        metrics.increment("queries.${query::class.simpleName}")
    }
}
```

</TabItem>
</Tabs>

## Metadata

Messages can include **metadata** (key–value context like user agent, correlation IDs, etc.).

Send metadata with a command:

<Tabs>
<TabItem value="Java" label="Java">

```java
Fluxzero.sendCommand(
    new CreateUser(...),
    Metadata.of("userAgent", userAgent)
);
```

</TabItem>
<TabItem value="Kotlin" label="Kotlin">

```kotlin
Fluxzero.sendCommand(
    CreateUser(...),
    Metadata.of("userAgent", userAgent)
)
```

</TabItem>
</Tabs>

Read metadata in a handler:

<Tabs>
<TabItem value="Java" label="Java">

```java
class UserCommandHandler {
    @HandleCommand
    void handle(CreateUser command, Metadata metadata) {
        String agent = metadata.get("userAgent");
        // ...
    }
}
```

</TabItem>
<TabItem value="Kotlin" label="Kotlin">

```kotlin
class UserCommandHandler {
    @HandleCommand
    fun handle(command: CreateUser, metadata: Metadata) {
        val agent = metadata.get("userAgent")
        // ...
    }
}
```

</TabItem>
</Tabs>