---
title: Aggregate
description: Understanding aggregates as consistency boundaries in Fluxzero
sidebar:
   order: 40
---

import { Tabs, TabItem, Card, CardGrid, Aside } from '@astrojs/starlight/components';

An **Aggregate** is a specialized root entity that serves as the entry point into a domain model. It represents a single unit of consistency and can contain nested child entities. Aggregates are the foundation of domain-driven design in Fluxzero.

<Aside type="tip" title="Real-world analogy">
Think of an aggregate like a smart home system. The main controller (aggregate root) manages all connected devices (entities) as one cohesive unit. You can't control individual devices without going through the main controller, ensuring everything stays synchronized.
</Aside>

## Key Concepts

<CardGrid>
<Card title="Consistency Boundary" icon="shield">
Aggregates ensure that all changes within the boundary happen together or not at all, maintaining data consistency across related entities.
</Card>

<Card title="Single Entry Point" icon="rocket">
All access to entities within an aggregate must go through the aggregate root, controlling how data can be modified.
</Card>

<Card title="Event Sourcing" icon="document">
By default, aggregates use event sourcing to track all changes as a sequence of events that can be replayed to rebuild state.
</Card>

<Card title="Nested Entities" icon="list-format">
Aggregates can contain child entities with their own identities, creating rich domain models with complex relationships.
</Card>
</CardGrid>

## Defining Aggregates

### Basic Aggregate

<Tabs>
<TabItem label="Java">
```java
@Aggregate
@Builder(toBuilder = true)
public record SmartHome(@EntityId HomeId homeId,
                        String address,
                        boolean securityEnabled) {
    // Aggregate root for home automation system
}
```
</TabItem>
<TabItem label="Kotlin">
```kotlin
@Aggregate
data class SmartHome(@EntityId val homeId: HomeId,
                     val address: String,
                     val securityEnabled: Boolean) {
    // Aggregate root for home automation system
}
```
</TabItem>
</Tabs>

### Aggregate with Child Entities

<Tabs>
<TabItem label="Java">
```java
@Aggregate
@Builder(toBuilder = true)
public record SmartHome(@EntityId HomeId homeId,
                        String address,
                        boolean securityEnabled,
                        @Member List<Room> rooms,
                        @Member List<Device> devices) {
    
    // Business logic methods
    public SmartHome addRoom(Room room) {
        List<Room> updatedRooms = new ArrayList<>(rooms);
        updatedRooms.add(room);
        return toBuilder().rooms(updatedRooms).build();
    }
}

public record Room(@EntityId RoomId roomId,
                   String name,
                   RoomType type,
                   @Member List<Device> roomDevices) {
    
    public enum RoomType {
        LIVING_ROOM, BEDROOM, KITCHEN, BATHROOM, GARAGE
    }
}

public record Device(@EntityId DeviceId deviceId,
                     String name,
                     DeviceType type,
                     boolean isOnline,
                     Map<String, Object> settings) {
    
    public enum DeviceType {
        LIGHT, THERMOSTAT, LOCK, CAMERA, SENSOR
    }
}
```
</TabItem>
<TabItem label="Kotlin">
```kotlin
@Aggregate
data class SmartHome(@EntityId val homeId: HomeId,
                     val address: String,
                     val securityEnabled: Boolean,
                     @Member val rooms: List<Room> = emptyList(),
                     @Member val devices: List<Device> = emptyList()) {
    
    // Business logic methods
    fun addRoom(room: Room): SmartHome {
        return copy(rooms = rooms + room)
    }
}

data class Room(@EntityId val roomId: RoomId,
                val name: String,
                val type: RoomType,
                @Member val roomDevices: List<Device> = emptyList()) {
    
    enum class RoomType {
        LIVING_ROOM, BEDROOM, KITCHEN, BATHROOM, GARAGE
    }
}

data class Device(@EntityId val deviceId: DeviceId,
                  val name: String,
                  val type: DeviceType,
                  val isOnline: Boolean,
                  val settings: Map<String, Any> = emptyMap()) {
    
    enum class DeviceType {
        LIGHT, THERMOSTAT, LOCK, CAMERA, SENSOR
    }
}
```
</TabItem>
</Tabs>

## Strongly Typed Identifiers

Use strongly typed identifiers extending `Id<T>` for better type safety:

<Tabs>
<TabItem label="Java">
```java
public class HomeId extends Id<SmartHome> {
    public HomeId(String id) {
        super(id);
    }
    
    public static HomeId generate() {
        return new HomeId(UUID.randomUUID().toString());
    }
}

public class RoomId extends Id<Room> {
    public RoomId(String id) {
        super(id);
    }
    
    public static RoomId generate() {
        return new RoomId(UUID.randomUUID().toString());
    }
}

public class DeviceId extends Id<Device> {
    public DeviceId(String id) {
        super(id);
    }
    
    public static DeviceId generate() {
        return new DeviceId(UUID.randomUUID().toString());
    }
}
```
</TabItem>
<TabItem label="Kotlin">
```kotlin
class HomeId(id: String) : Id<SmartHome>(id) {
    companion object {
        fun generate(): HomeId = HomeId(UUID.randomUUID().toString())
    }
}

class RoomId(id: String) : Id<Room>(id) {
    companion object {
        fun generate(): RoomId = RoomId(UUID.randomUUID().toString())
    }
}

class DeviceId(id: String) : Id<Device>(id) {
    companion object {
        fun generate(): DeviceId = DeviceId(UUID.randomUUID().toString())
    }
}
```
</TabItem>
</Tabs>

## Loading Aggregates

Fluxzero provides several ways to load aggregates and their entities:

### Load by Aggregate ID

<Tabs>
<TabItem label="Java">
```java
// Load complete smart home aggregate
SmartHome home = FluxCapacitor.loadAggregate(homeId, SmartHome.class);

// Check if aggregate exists
Optional<SmartHome> homeOpt = FluxCapacitor.loadOptional(homeId, SmartHome.class);
```
</TabItem>
<TabItem label="Kotlin">
```kotlin
// Load complete smart home aggregate
val home = FluxCapacitor.loadAggregate(homeId, SmartHome::class.java)

// Check if aggregate exists
val homeOpt = FluxCapacitor.loadOptional(homeId, SmartHome::class.java)
```
</TabItem>
</Tabs>

### Load by Entity ID

<Tabs>
<TabItem label="Java">
```java
// Load aggregate containing a specific room
SmartHome home = FluxCapacitor.loadAggregateFor(roomId);

// Load just the room entity
Room room = FluxCapacitor.loadEntity(roomId);

// Load just the device entity
Device device = FluxCapacitor.loadEntity(deviceId);
```
</TabItem>
<TabItem label="Kotlin">
```kotlin
// Load aggregate containing a specific room
val home = FluxCapacitor.loadAggregateFor(roomId)

// Load just the room entity
val room = FluxCapacitor.loadEntity<Room>(roomId)

// Load just the device entity
val device = FluxCapacitor.loadEntity<Device>(deviceId)
```
</TabItem>
</Tabs>

## Event Sourcing with Aggregates

By default, aggregates use event sourcing. State changes are captured as events and applied using `@Apply` methods:

<Tabs>
<TabItem label="Java">
```java
// Command to add a new room
public record AddRoom(HomeId homeId, Room room) {
    
    @Apply
    SmartHome apply(SmartHome home) {
        if (home == null) {
            throw new IllegalStateException("Smart home does not exist");
        }
        
        List<Room> updatedRooms = new ArrayList<>(home.rooms());
        updatedRooms.add(room);
        
        return home.toBuilder().rooms(updatedRooms).build();
    }
}

// Event published after room is added
public record RoomAdded(HomeId homeId, Room room) {}
```
</TabItem>
<TabItem label="Kotlin">
```kotlin
// Command to add a new room
data class AddRoom(val homeId: HomeId, val room: Room) {
    
    @Apply
    fun apply(home: SmartHome?): SmartHome {
        requireNotNull(home) { "Smart home does not exist" }
        
        return home.copy(rooms = home.rooms + room)
    }
}

// Event published after room is added
data class RoomAdded(val homeId: HomeId, val room: Room)
```
</TabItem>
</Tabs>

## Validation with `@AssertLegal`

Add validation logic to ensure business rules are enforced:

<Tabs>
<TabItem label="Java">
```java
public record AddDevice(HomeId homeId, RoomId roomId, Device device) {
    
    @AssertLegal
    void validateDeviceAddition(SmartHome home) {
        if (home == null) {
            throw new IllegalCommandException("Smart home does not exist");
        }
        
        // Check if room exists
        boolean roomExists = home.rooms().stream()
            .anyMatch(room -> room.roomId().equals(roomId));
        
        if (!roomExists) {
            throw new IllegalCommandException("Room not found: " + roomId);
        }
        
        // Check for duplicate device names in the home
        boolean deviceExists = home.devices().stream()
            .anyMatch(existingDevice -> 
                existingDevice.name().equals(device.name()));
        
        if (deviceExists) {
            throw new IllegalCommandException(
                "Device with name '" + device.name() + "' already exists");
        }
    }
    
    @Apply
    SmartHome apply(SmartHome home) {
        // Add device to home's main device list
        List<Device> updatedDevices = new ArrayList<>(home.devices());
        updatedDevices.add(device);
        
        // Add device to specific room
        List<Room> updatedRooms = home.rooms().stream()
            .map(room -> {
                if (room.roomId().equals(roomId)) {
                    List<Device> roomDevices = new ArrayList<>(room.roomDevices());
                    roomDevices.add(device);
                    return room.toBuilder().roomDevices(roomDevices).build();
                }
                return room;
            })
            .toList();
        
        return home.toBuilder()
            .devices(updatedDevices)
            .rooms(updatedRooms)
            .build();
    }
}
```
</TabItem>
<TabItem label="Kotlin">
```kotlin
data class AddDevice(val homeId: HomeId, val roomId: RoomId, val device: Device) {
    
    @AssertLegal
    fun validateDeviceAddition(home: SmartHome?) {
        requireNotNull(home) { "Smart home does not exist" }
        
        // Check if room exists
        val roomExists = home.rooms.any { it.roomId == roomId }
        require(roomExists) { "Room not found: $roomId" }
        
        // Check for duplicate device names in the home
        val deviceExists = home.devices.any { it.name == device.name }
        require(!deviceExists) { "Device with name '${device.name}' already exists" }
    }
    
    @Apply
    fun apply(home: SmartHome): SmartHome {
        // Add device to home's main device list
        val updatedDevices = home.devices + device
        
        // Add device to specific room
        val updatedRooms = home.rooms.map { room ->
            if (room.roomId == roomId) {
                room.copy(roomDevices = room.roomDevices + device)
            } else {
                room
            }
        }
        
        return home.copy(
            devices = updatedDevices,
            rooms = updatedRooms
        )
    }
}
```
</TabItem>
</Tabs>

## Configuration Options

### Event Sourcing Configuration

<Tabs>
<TabItem label="Java">
```java
// Enable snapshots for performance optimization
@Aggregate(snapshotPeriod = 1000)
public record SmartHome(@EntityId HomeId homeId, /*...*/) {
    // Snapshot will be created every 1000 events
}

// Disable event sourcing for simple aggregates
@Aggregate(eventSourced = false)
public record DeviceTemplate(@EntityId String templateId,
                             String name,
                             DeviceType type,
                             Map<String, Object> defaultSettings) {
    // Stored as current state only, no event history
}
```
</TabItem>
<TabItem label="Kotlin">
```kotlin
// Enable snapshots for performance optimization
@Aggregate(snapshotPeriod = 1000)
data class SmartHome(@EntityId val homeId: HomeId, /*...*/) {
    // Snapshot will be created every 1000 events
}

// Disable event sourcing for simple aggregates
@Aggregate(eventSourced = false)
data class DeviceTemplate(@EntityId val templateId: String,
                          val name: String,
                          val type: DeviceType,
                          val defaultSettings: Map<String, Any>) {
    // Stored as current state only, no event history
}
```
</TabItem>
</Tabs>

### Search Integration

<Tabs>
<TabItem label="Java">
```java
// Make aggregate searchable
@Aggregate(eventSourced = false, searchable = true, collection = "homes")
public record SmartHome(@EntityId HomeId homeId,
                        String address,
                        boolean securityEnabled,
                        List<String> tags) {
    // This aggregate will be indexed for full-text search
}

// Search for homes
List<SmartHome> secureHomes = FluxCapacitor
    .search(SmartHome.class)
    .match("true", "securityEnabled")
    .fetchAll();

List<SmartHome> homesInCity = FluxCapacitor
    .search(SmartHome.class)
    .match("Amsterdam", "address")
    .fetch(10);
```
</TabItem>
<TabItem label="Kotlin">
```kotlin
// Make aggregate searchable
@Aggregate(eventSourced = false, searchable = true, collection = "homes")
data class SmartHome(@EntityId val homeId: HomeId,
                     val address: String,
                     val securityEnabled: Boolean,
                     val tags: List<String> = emptyList()) {
    // This aggregate will be indexed for full-text search
}

// Search for homes
val secureHomes = FluxCapacitor
    .search(SmartHome::class.java)
    .match("true", "securityEnabled")
    .fetchAll()

val homesInCity = FluxCapacitor
    .search(SmartHome::class.java)
    .match("Amsterdam", "address")
    .fetch(10)
```
</TabItem>
</Tabs>

## Complex Aggregate Example

Here's a complete smart home aggregate with multiple entity types:

<Tabs>
<TabItem label="Java">
```java
@Aggregate
@Builder(toBuilder = true)
public record SmartHome(
    @EntityId HomeId homeId,
    String address,
    String ownerName,
    boolean securityEnabled,
    @Member List<Room> rooms,
    @Member List<Device> devices,
    @Member List<AutomationRule> automationRules,
    @Member List<SecurityEvent> securityEvents) {
    
    // Business methods
    public boolean hasDeviceType(DeviceType type) {
        return devices.stream()
            .anyMatch(device -> device.type() == type);
    }
    
    public List<Device> getOnlineDevices() {
        return devices.stream()
            .filter(Device::isOnline)
            .toList();
    }
    
    public Room findRoom(RoomId roomId) {
        return rooms.stream()
            .filter(room -> room.roomId().equals(roomId))
            .findFirst()
            .orElse(null);
    }
}

public record AutomationRule(
    @EntityId RuleId ruleId,
    String name,
    String description,
    boolean enabled,
    RuleTrigger trigger,
    List<RuleAction> actions) {
    
    public record RuleTrigger(
        String type,  // "time", "device_state", "sensor_value"
        Map<String, Object> conditions
    ) {}
    
    public record RuleAction(
        String type,  // "device_control", "notification", "security"
        Map<String, Object> parameters
    ) {}
}

public record SecurityEvent(
    @EntityId String eventId,
    Instant timestamp,
    SecurityEventType type,
    String description,
    DeviceId sourceDeviceId,
    boolean resolved) {
    
    public enum SecurityEventType {
        UNAUTHORIZED_ACCESS, DEVICE_OFFLINE, SENSOR_TRIGGERED, SYSTEM_ARMED
    }
}
```
</TabItem>
<TabItem label="Kotlin">
```kotlin
@Aggregate
data class SmartHome(
    @EntityId val homeId: HomeId,
    val address: String,
    val ownerName: String,
    val securityEnabled: Boolean,
    @Member val rooms: List<Room> = emptyList(),
    @Member val devices: List<Device> = emptyList(),
    @Member val automationRules: List<AutomationRule> = emptyList(),
    @Member val securityEvents: List<SecurityEvent> = emptyList()) {
    
    // Business methods
    fun hasDeviceType(type: DeviceType): Boolean {
        return devices.any { it.type == type }
    }
    
    fun getOnlineDevices(): List<Device> {
        return devices.filter { it.isOnline }
    }
    
    fun findRoom(roomId: RoomId): Room? {
        return rooms.find { it.roomId == roomId }
    }
}

data class AutomationRule(
    @EntityId val ruleId: RuleId,
    val name: String,
    val description: String,
    val enabled: Boolean,
    val trigger: RuleTrigger,
    val actions: List<RuleAction>) {
    
    data class RuleTrigger(
        val type: String,  // "time", "device_state", "sensor_value"
        val conditions: Map<String, Any>
    )
    
    data class RuleAction(
        val type: String,  // "device_control", "notification", "security"
        val parameters: Map<String, Any>
    )
}

data class SecurityEvent(
    @EntityId val eventId: String,
    val timestamp: Instant,
    val type: SecurityEventType,
    val description: String,
    val sourceDeviceId: DeviceId,
    val resolved: Boolean) {
    
    enum class SecurityEventType {
        UNAUTHORIZED_ACCESS, DEVICE_OFFLINE, SENSOR_TRIGGERED, SYSTEM_ARMED
    }
}
```
</TabItem>
</Tabs>

## Best Practices

### 1. Keep Aggregates Focused
```java
// Good: Focused on home automation domain
@Aggregate
public record SmartHome(/* home-related properties */) {}

// Bad: Mixed concerns
@Aggregate  
public record HomeWithBilling(/* home properties + billing properties */) {}
```

### 2. Use Meaningful Entity IDs
```java
// Good: Strongly typed, domain-specific IDs
public class HomeId extends Id<SmartHome> { /*...*/ }
public class DeviceId extends Id<Device> { /*...*/ }

// Bad: Generic string IDs everywhere
public record SmartHome(@EntityId String id, /*...*/) {}
```

### 3. Model Business Invariants
```java
public record SetTemperature(DeviceId thermostatId, double temperature) {
    @AssertLegal
    void validateTemperature(Device thermostat) {
        if (thermostat.type() != DeviceType.THERMOSTAT) {
            throw new IllegalCommandException("Device is not a thermostat");
        }
        
        if (temperature < 10.0 || temperature > 35.0) {
            throw new IllegalCommandException(
                "Temperature must be between 10°C and 35°C");
        }
    }
}
```

### 4. Consider Performance with Snapshots
```java
// For aggregates with many events, enable snapshots
@Aggregate(snapshotPeriod = 500)
public record SmartHome(/*...*/) {
    // Snapshot created every 500 events to speed up loading
}
```

## Common Patterns

### Factory Pattern for Creation
<Tabs>
<TabItem label="Java">
```java
public record CreateSmartHome(String address, String ownerName) {
    
    @Apply
    SmartHome apply() {
        return SmartHome.builder()
            .homeId(HomeId.generate())
            .address(address)
            .ownerName(ownerName)
            .securityEnabled(false)
            .rooms(List.of())
            .devices(List.of())
            .automationRules(List.of())
            .securityEvents(List.of())
            .build();
    }
}
```
</TabItem>
<TabItem label="Kotlin">
```kotlin
data class CreateSmartHome(val address: String, val ownerName: String) {
    
    @Apply
    fun apply(): SmartHome {
        return SmartHome(
            homeId = HomeId.generate(),
            address = address,
            ownerName = ownerName,
            securityEnabled = false
        )
    }
}
```
</TabItem>
</Tabs>

### Batch Operations
<Tabs>
<TabItem label="Java">
```java
public record AddMultipleDevices(HomeId homeId, List<Device> devices) {
    
    @Apply
    SmartHome apply(SmartHome home) {
        List<Device> allDevices = new ArrayList<>(home.devices());
        allDevices.addAll(devices);
        
        return home.toBuilder().devices(allDevices).build();
    }
}
```
</TabItem>
<TabItem label="Kotlin">
```kotlin
data class AddMultipleDevices(val homeId: HomeId, val devices: List<Device>) {
    
    @Apply
    fun apply(home: SmartHome): SmartHome {
        return home.copy(devices = home.devices + devices)
    }
}
```
</TabItem>
</Tabs>

## Related Concepts

- **[Event Sourcing](/reference/core-components/event-sourcing)** - How aggregates track state changes as events
- **[Handlers](/reference/core-components/handler)** - Processing commands and events for aggregates
- **[Commands](/reference/core-components/command)** - Requesting changes to aggregates
- **[Events](/reference/core-components/event)** - Notifications when aggregates change
- **[Document Store](/reference/core-components/document)** - Alternative storage for non-event-sourced aggregates