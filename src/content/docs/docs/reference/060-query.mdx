---
title: Query
description: How to use queries for data retrieval in Fluxzero
slug: docs/reference/query
sidebar:
   order: 60
---

import { Tabs, TabItem, Aside } from '@astrojs/starlight/components';

## Queries

Queries in Fluxzero are used to retrieve data from the system, typically from projections or read models. They are a core part of the CQRS pattern, and are always side-effect free.

### Introduction

Queries are used whenever you want to fetch information, such as:
- Getting the contents of a shopping cart
- Searching for products by keyword
- Retrieving project details for display

Queries are handled by query handlers, which are regular classes or methods annotated to process specific query types.

### Keep the logic with the query

You can keep the handler logic close to the query definition for clarity and maintainability.

<Tabs>
<TabItem label="Java">
```java
public class GetCartItems implements Request<List<Item>> {
    private final String cartId;
    public GetCartItems(String cartId) { this.cartId = cartId; }

    @HandleQuery
    List<Item> handle(CartRepository repo) {
        return repo.findItemsByCartId(cartId);
    }
}
```
</TabItem>
<TabItem label="Kotlin">
```kotlin
data class GetCartItems(val cartId: String) : Request<List<Item>> {
    @HandleQuery
    fun handle(repo: CartRepository): List<Item> =
        repo.findItemsByCartId(cartId)
}
```
</TabItem>
</Tabs>

### Specifying return type

Queries should implement `Request<R>` to indicate the expected result type, giving compile-time type safety.

<Tabs>
<TabItem label="Java">
```java
public record GetProductDetails(String productId) implements Request<ProductDetails> {}
```
</TabItem>
<TabItem label="Kotlin">
```kotlin
data class GetProductDetails(val productId: String) : Request<ProductDetails>
```
</TabItem>
</Tabs>

### Full-text search out of the box

Fluxzero queries can leverage full-text search on projections or document stores.

<Tabs>
<TabItem label="Java">
```java
public record SearchProducts(String term) implements Request<List<Product>> {}

@HandleQuery
public List<Product> handle(SearchProducts query, ProductSearchService search) {
    return search.fullTextSearch(query.term());
}
```
</TabItem>
<TabItem label="Kotlin">
```kotlin
data class SearchProducts(val term: String) : Request<List<Product>>

@HandleQuery
fun handle(query: SearchProducts, search: ProductSearchService): List<Product> =
    search.fullTextSearch(query.term)
```
</TabItem>
</Tabs>

### Composing queries

You can compose queries to build up more complex data retrieval, such as aggregating results from multiple queries.

<Tabs>
<TabItem label="Java">
```java
public class ProjectOverviewService {
    public ProjectOverview getOverview(String projectId) {
        ProjectDetails details = Fluxzero.queryAndWait(new GetProjectDetails(projectId));
        List<Task> tasks = Fluxzero.queryAndWait(new GetProjectTasks(projectId));
        return new ProjectOverview(details, tasks);
    }
}
```
</TabItem>
<TabItem label="Kotlin">
```kotlin
class ProjectOverviewService {
    fun getOverview(projectId: String): ProjectOverview {
        val details = Fluxzero.queryAndWait(GetProjectDetails(projectId))
        val tasks = Fluxzero.queryAndWait(GetProjectTasks(projectId))
        return ProjectOverview(details, tasks)
    }
}
```
</TabItem>
</Tabs>

### When to use separate handlers

Use separate query handlers when:
- You want to keep query and handler logic decoupled (e.g. for reuse)
- You have a query type handled in multiple places (e.g. for routing)
- You want to apply cross-cutting concerns (e.g. logging, metrics)

<Aside type="tip" title="Tip">
For simple queries, keeping the handler logic in the query class is convenient. For more complex scenarios, define dedicated handler classes.
</Aside>