---
// Floating feedback component that anchors feedback to selected text locations
export interface Props {
  slug?: string;
  className?: string;
}

const { slug, className = '' } = Astro.props;

// Use current page path if no slug provided
const currentSlug = slug || Astro.url.pathname;
const componentId = `floating-feedback-${Math.random().toString(36).substr(2, 9)}`;
---

<div id={componentId} class={`floating-feedback-container ${className}`}>
  <!-- Feedback indicators will be injected here -->
</div>

<script define:vars={{ currentSlug, componentId }}>
  class FloatingFeedback {
    constructor(container, slug) {
      this.container = container;
      this.slug = slug;
      this.feedback = null;
      this.indicators = [];
      this.activePopup = null;

      this.init();
    }

    async init() {
      await this.fetchFeedback();
      this.processTextSelections();
      this.setupScrollListener();
    }

    async fetchFeedback() {
      try {
        const response = await fetch(`/api/feedback?slug=${encodeURIComponent(this.slug)}`);
        if (!response.ok) {
          throw new Error(`Failed to fetch feedback: ${response.status}`);
        }
        this.feedback = await response.json();
      } catch (err) {
        console.error('Error fetching feedback:', err);
      }
    }

    processTextSelections() {
      if (!this.feedback || this.feedback.discussions.length === 0) return;

      this.feedback.discussions.forEach((discussion, index) => {
        const selectedText = this.extractSelectedText(discussion);
        const textLocation = this.findTextInPage(selectedText);

        if (textLocation) {
          this.createFeedbackIndicator(discussion, textLocation, index);
        }
      });
    }

    extractSelectedText(discussion) {
      if (discussion.metadata?.selection?.text) {
        return discussion.metadata.selection.text;
      }

      // Fallback: extract quoted text from body
      const quoteMatch = discussion.body.match(/>\s*([^\n]+)/);
      return quoteMatch?.[1] || null;
    }

    findTextInPage(selectedText) {
      if (!selectedText) return null;

      // Find the text in the page content
      const walker = document.createTreeWalker(
        document.body,
        NodeFilter.SHOW_TEXT,
        {
          acceptNode: function(node) {
            // Skip script and style elements
            const parent = node.parentElement;
            if (parent.tagName === 'SCRIPT' || parent.tagName === 'STYLE') {
              return NodeFilter.FILTER_REJECT;
            }
            return NodeFilter.FILTER_ACCEPT;
          }
        }
      );

      let node;
      while (node = walker.nextNode()) {
        const text = node.textContent;
        const index = text.indexOf(selectedText);

        if (index !== -1) {
          // Found the text, return position info
          const range = document.createRange();
          range.setStart(node, index);
          range.setEnd(node, index + selectedText.length);

          return {
            range,
            rect: range.getBoundingClientRect(),
            element: node.parentElement,
            text: selectedText
          };
        }
      }

      return null;
    }

    createFeedbackIndicator(discussion, textLocation, index) {
      // Wrap the selected text in a span with feedback indicator
      const span = document.createElement('span');
      span.className = 'feedback-highlight';
      span.dataset.feedbackId = discussion.id;
      span.dataset.feedbackIndex = index;

      // Extract the text node content
      const range = textLocation.range;
      const selectedText = range.extractContents();
      span.appendChild(selectedText);

      // Insert the span back
      range.insertNode(span);

      // Create floating indicator
      const indicator = document.createElement('div');
      indicator.className = 'feedback-indicator';
      indicator.innerHTML = `
        <div class="feedback-badge">
          ðŸ’¬ ${discussion.commentCount || 0}
        </div>
      `;

      // Position the indicator
      this.updateAbsolutePosition(indicator, span);

      // Add click handler
      indicator.addEventListener('click', (e) => {
        e.preventDefault();
        this.showFeedbackPopup(discussion, indicator);
      });

      // Hide indicator by default
      indicator.style.opacity = '0';
      indicator.style.pointerEvents = 'none';

      let hideTimeout;

      const hideIndicator = () => {
        indicator.style.opacity = '0';
        indicator.style.pointerEvents = 'none';
        indicator.style.transform = 'scale(0.8)';
      };

      const showIndicator = () => {
        clearTimeout(hideTimeout);
        indicator.style.opacity = '0.8';
        indicator.style.pointerEvents = 'auto';
        indicator.style.transform = 'scale(1)';
      };

      const scheduleHide = (delay = 200) => {
        // Don't hide indicator if popup is open
        if (this.activePopup) return;

        clearTimeout(hideTimeout);
        hideTimeout = setTimeout(hideIndicator, delay);
      };

      // Show indicator when hovering over highlighted text
      span.addEventListener('mouseenter', showIndicator);

      // Hide indicator when leaving highlighted text (with delay for moving to indicator)
      span.addEventListener('mouseleave', () => {
        scheduleHide(300); // Give user time to move to indicator
      });

      // Keep indicator visible and enhance when hovering over it
      indicator.addEventListener('mouseenter', () => {
        clearTimeout(hideTimeout);
        indicator.style.opacity = '1';
        indicator.style.transform = 'scale(1.1)';
      });

      // Hide indicator when leaving it
      indicator.addEventListener('mouseleave', () => {
        scheduleHide(100);
      });

      // Add to DOM
      document.body.appendChild(indicator);

      this.indicators.push({
        element: indicator,
        discussion,
        anchor: span
      });
    }



    setupScrollListener() {
      // Use position: absolute instead of fixed for better performance
      this.indicators.forEach(({ element, anchor }) => {
        element.style.position = 'absolute';
        this.updateAbsolutePosition(element, anchor);
      });

      // More responsive scroll handling
      let ticking = false;

      const updatePositions = () => {
        this.indicators.forEach(({ element, anchor }) => {
          this.updateAbsolutePosition(element, anchor);
        });

        // Update popup position if open
        if (this.activePopup && this.activePopup.associatedIndicator) {
          this.updatePopupPosition(this.activePopup, this.activePopup.associatedIndicator);
        }

        ticking = false;
      };

      window.addEventListener('scroll', () => {
        if (!ticking) {
          requestAnimationFrame(updatePositions);
          ticking = true;
        }
      }, { passive: true });

      // Update positions on resize
      window.addEventListener('resize', () => {
        if (!ticking) {
          requestAnimationFrame(updatePositions);
          ticking = true;
        }
      });
    }

    updateAbsolutePosition(indicator, anchor) {
      const rect = anchor.getBoundingClientRect();
      const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
      const scrollLeft = window.pageXOffset || document.documentElement.scrollLeft;

      indicator.style.left = `${rect.right + scrollLeft + 10}px`;
      indicator.style.top = `${rect.top + scrollTop + (rect.height / 2) - 12}px`;
    }

    showFeedbackPopup(discussion, indicator) {
      // Close existing popup
      if (this.activePopup) {
        this.activePopup.remove();
      }

      // Create popup
      const popup = document.createElement('div');
      popup.className = 'feedback-popup';

      const cleanTitle = discussion.title.replace(/^\[slug:[^\]]+\]\s*/, '');

      popup.innerHTML = `
        <div class="feedback-popup-header">
          <h4>${cleanTitle}</h4>
          <button class="feedback-close">&times;</button>
        </div>
        <div class="feedback-popup-content">
          <div class="feedback-author">
            <img src="${discussion.author.avatarUrl}" alt="${discussion.author.login}" width="24" height="24">
            <span>${discussion.author.login}</span>
            <time>${this.formatDate(discussion.createdAt)}</time>
          </div>
          <div class="feedback-selected-text">
            <strong>About:</strong> "${this.extractSelectedText(discussion)}"
          </div>
          <div class="feedback-body">
            ${discussion.body.slice(0, 300)}${discussion.body.length > 300 ? '...' : ''}
          </div>
          <div class="feedback-actions">
            <a href="${discussion.url}" target="_blank" rel="noopener noreferrer">
              View full discussion â†’
            </a>
          </div>
        </div>
      `;

      // Position popup near indicator (fixed position)
      this.updatePopupPosition(popup, indicator);
      popup.style.position = 'fixed';
      popup.style.zIndex = '2000';

      // Store reference for position updates
      popup.associatedIndicator = indicator;

      // Add close handler
      const closePopup = () => {
        popup.remove();
        this.activePopup = null;

        // Hide the indicator when popup closes
        indicator.style.opacity = '0';
        indicator.style.pointerEvents = 'none';
        indicator.style.transform = 'scale(0.8)';
      };

      popup.querySelector('.feedback-close').addEventListener('click', closePopup);

      // Close on click outside (but not on indicator)
      setTimeout(() => {
        const handleOutsideClick = (e) => {
          if (!popup.contains(e.target) && e.target !== indicator && !indicator.contains(e.target)) {
            closePopup();
            document.removeEventListener('click', handleOutsideClick);
          }
        };
        document.addEventListener('click', handleOutsideClick);
      }, 100);

      document.body.appendChild(popup);
      this.activePopup = popup;
    }

    updatePopupPosition(popup, indicator) {
      const indicatorRect = indicator.getBoundingClientRect();
      const popupWidth = 320;

      // Calculate optimal position
      let left = indicatorRect.left;
      let top = indicatorRect.bottom + 10;

      // Ensure popup stays within viewport
      if (left + popupWidth > window.innerWidth) {
        left = window.innerWidth - popupWidth - 10;
      }
      if (left < 10) {
        left = 10;
      }

      // If popup would go below viewport, show above indicator
      if (top + 400 > window.innerHeight) {
        top = indicatorRect.top - 410; // Approximate popup height
      }

      popup.style.left = `${left}px`;
      popup.style.top = `${top}px`;
    }

    formatDate(dateString) {
      return new Date(dateString).toLocaleDateString('en-US', {
        year: 'numeric',
        month: 'short',
        day: 'numeric'
      });
    }
  }

  // Initialize when DOM is ready
  document.addEventListener('DOMContentLoaded', () => {
    const container = document.getElementById(componentId);
    if (container) {
      new FloatingFeedback(container, currentSlug);
    }
  });
</script>

<style>
  .floating-feedback-container {
    /* Container doesn't need visible styling */
  }

  /* Highlighted text styling */
  :global(.feedback-highlight) {
    background: linear-gradient(90deg, transparent 0%, rgba(59, 130, 246, 0.1) 10%, rgba(59, 130, 246, 0.1) 90%, transparent 100%);
    border-bottom: 2px dashed rgba(59, 130, 246, 0.3);
    position: relative;
    cursor: help;
    transition: all 0.2s ease;
  }

  :global(.feedback-highlight:hover) {
    background: linear-gradient(90deg, transparent 0%, rgba(59, 130, 246, 0.2) 10%, rgba(59, 130, 246, 0.2) 90%, transparent 100%);
    border-bottom-color: rgba(59, 130, 246, 0.6);
    box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.1);
  }

  /* Floating indicator */
  :global(.feedback-indicator) {
    position: absolute;
    cursor: pointer;
    transition: opacity 0.2s ease, transform 0.2s ease;
    opacity: 0.7;
    transform: scale(0.8);
    z-index: 1000;
    pointer-events: auto;
  }

  :global(.feedback-badge) {
    background: #3b82f6;
    color: white;
    padding: 4px 8px;
    border-radius: 12px;
    font-size: 12px;
    font-weight: 500;
    white-space: nowrap;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
  }

  :global(.feedback-indicator:hover) {
    opacity: 1 !important;
    transform: scale(1.1) !important;
  }

  /* Popup styling */
  :global(.feedback-popup) {
    background: white;
    border: 1px solid #e5e7eb;
    border-radius: 8px;
    box-shadow: 0 10px 25px rgba(0, 0, 0, 0.15);
    width: 300px;
    max-height: 400px;
    overflow: hidden;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
  }

  :global(.feedback-popup-header) {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 12px 16px;
    background: #f9fafb;
    border-bottom: 1px solid #e5e7eb;
  }

  :global(.feedback-popup-header h4) {
    margin: 0;
    font-size: 14px;
    font-weight: 600;
    color: #1f2937;
    flex: 1;
    margin-right: 12px;
  }

  :global(.feedback-close) {
    background: none;
    border: none;
    font-size: 18px;
    cursor: pointer;
    color: #6b7280;
    padding: 0;
    width: 20px;
    height: 20px;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  :global(.feedback-close:hover) {
    color: #1f2937;
  }

  :global(.feedback-popup-content) {
    padding: 16px;
  }

  :global(.feedback-author) {
    display: flex;
    align-items: center;
    gap: 8px;
    margin-bottom: 12px;
    font-size: 12px;
    color: #6b7280;
  }

  :global(.feedback-author img) {
    border-radius: 50%;
    border: 1px solid #e5e7eb;
  }

  :global(.feedback-author span) {
    font-weight: 500;
    color: #1f2937;
  }

  :global(.feedback-selected-text) {
    background: #f3f4f6;
    border-left: 3px solid #3b82f6;
    padding: 8px 12px;
    margin: 12px 0;
    border-radius: 0 4px 4px 0;
    font-size: 12px;
    color: #4b5563;
    font-style: italic;
  }

  :global(.feedback-body) {
    font-size: 13px;
    line-height: 1.5;
    color: #1f2937;
    margin-bottom: 12px;
  }

  :global(.feedback-actions a) {
    color: #3b82f6;
    text-decoration: none;
    font-size: 12px;
    font-weight: 500;
  }

  :global(.feedback-actions a:hover) {
    text-decoration: underline;
  }

  /* Dark mode support */
  @media (prefers-color-scheme: dark) {
    :global(.feedback-popup) {
      background: #1f2937;
      border-color: #374151;
      color: #f9fafb;
    }

    :global(.feedback-popup-header) {
      background: #111827;
      border-color: #374151;
    }

    :global(.feedback-popup-header h4) {
      color: #f9fafb;
    }

    :global(.feedback-selected-text) {
      background: #374151;
      color: #d1d5db;
    }

    :global(.feedback-body) {
      color: #f9fafb;
    }
  }
</style>