---
title: Entity loading
sidebar:
   order: 180
---

import { Aside, Tabs, TabItem } from '@astrojs/starlight/components';

To change the state of an entity, use `Fluxzero.loadAggregate(...)` to retrieve the aggregate and apply updates to it.

Here's a basic example of a command handler applying a `CreateUser` update:

```java
public class UserCommandHandler {
    @HandleCommand
    void handle(CreateUser command) {
        Fluxzero.loadAggregate(command.getUserId()).assertAndApply(command);
    }
}
```

This loads the `UserAccount` entity by ID and applies the `CreateUser` command. Internally, Fluxzero will:

1. **Rehydrate** the entity using stored events or snapshots
2. **Run all `@AssertLegal` methods** to verify preconditions
3. **Call the `@Apply` method** to produce a new entity state
4. **Persist the event** in the aggregate event log (if event sourcing is active)
5. **Publish a domain event** (using the applied payload, unless overridden)

<Aside type="note">
  When loading an event-sourced <code>Entity</code> inside a message handler, Fluxzero automatically replays the entity up to the time of the handled message â€” not to the present. This ensures you always see the entity state as it was when the message occurred, even if later updates exist.
</Aside>

This example used `assertAndApply()`, which combines two steps:

[//]: # (@formatter:off)
```java
.aggregate(...)
  .assertLegal(update)
  .apply(update);
```
[//]: # (@formatter:on)

This style is recommended if you want to ensure validations happen before the entity changes state.
