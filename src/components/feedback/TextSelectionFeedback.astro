---
export interface Props {}
---

<script type="module">
  import { getState } from '/src/components/feedback/feedbackStore.ts';
  class SelectionPromptController {
    constructor() {
      this.el = null;
      this.tempHighlight = null;
      this.lastRange = null;
      this.lastText = '';
      this.handleSelectionChange = this.handleSelectionChange.bind(this);
      this.handleScrollOrResize = this.handleScrollOrResize.bind(this);
      this.onPromptClick = this.onPromptClick.bind(this);
      this.init();
    }

    init() {
      document.addEventListener('mouseup', this.handleSelectionChange);
      document.addEventListener('keyup', this.handleSelectionChange);
      document.addEventListener('touchend', this.handleSelectionChange, { passive: true });
      window.addEventListener('scroll', this.handleScrollOrResize, { passive: true });
      window.addEventListener('resize', this.handleScrollOrResize, { passive: true });
    }

    ensureEl() {
      if (this.el) return this.el;
      const el = document.createElement('div');
      el.className = 'feedback-selection-prompt';
      el.innerHTML = `ðŸ’¬ <span>Add a comment</span>`;
      el.style.position = 'fixed';
      el.style.zIndex = '2000';
      el.style.display = 'none';
      document.body.appendChild(el);
      this.el = el;
      this.el.addEventListener('click', this.onPromptClick);
      return el;
    }

    handleScrollOrResize() {
      if (this.el && this.el.style.display !== 'none') {
        const sel = window.getSelection();
        if (sel && sel.rangeCount > 0 && !sel.isCollapsed) {
          const range = sel.getRangeAt(0);
          this.position(range);
        } else {
          this.hide();
        }
      }
    }

    handleSelectionChange() {
      const sel = window.getSelection();
      if (!sel || sel.rangeCount === 0 || sel.isCollapsed) {
        this.hide();
        return;
      }

      const range = sel.getRangeAt(0);

      // Ignore selections inside our own feedback UI
      const common = range.commonAncestorContainer instanceof Element
        ? range.commonAncestorContainer
        : range.commonAncestorContainer.parentElement;
      if (common && (common.closest('.floating-feedback-container') || common.closest('.feedback-popup') || common.closest('.feedback-indicator') || common.closest('.feedback-compose'))) {
        this.hide();
        return;
      }

      const text = sel.toString().trim();
      if (!text || text.length < 3) {
        this.hide();
        return;
      }

      // Cache current range and text for click, since clicking the prompt collapses selection
      this.lastRange = range.cloneRange();
      this.lastText = text;

      this.show(range);
    }

    onPromptClick(e) {
      e.preventDefault();
      // Use cached selection if the native selection collapsed after clicking
      let range = this.lastRange;
      let text = this.lastText;
      const sel = window.getSelection();
      if ((!range || !text) && sel && sel.rangeCount > 0 && !sel.isCollapsed) {
        range = sel.getRangeAt(0).cloneRange();
        text = sel.toString().trim();
      }
      if (!range || !text || text.length < 3) return;
      // Create a temporary highlight wrapper to preserve visual emphasis when selection blurs
      const span = document.createElement('span');
      span.className = 'feedback-highlight feedback-highlight--temp';
      const frag = range.extractContents();
      span.appendChild(frag);
      range.insertNode(span);
      this.tempHighlight = span;
      // Clear the native selection so focusing the popup doesn't reflow the page
      sel.removeAllRanges();
      this.hide();
      // Show compose popup near the highlighted text
      this.showComposer({ quote: text, anchor: span });
    }

    showComposer({ quote, anchor, preset }) {
      const existing = document.querySelector('.feedback-compose');
      if (existing) existing.remove();
      const popup = document.createElement('div');
      popup.className = 'feedback-compose';
      popup.innerHTML = `
        <div class="compose-header">
          <h4 class="compose-title">Add Feedback</h4>
          <button class="compose-close" aria-label="Close">&times;</button>
        </div>
        <div class="compose-body">
          <div class="compose-quote">${this.escapeHtml(quote)}</div>
          <label for="feedback-compose-text" style="display:none">Feedback</label>
          <textarea id="feedback-compose-text" placeholder="What would you like to tell us?" autofocus></textarea>
        </div>
        <div class="compose-actions">
          <div class="compose-actions-auth" data-auth="unknown">
            <span class="compose-auth-status" style="flex:1; font-size:12px; color:#6b7280"></span>
            <button class="btn" data-action="cancel">Cancel</button>
            <button class="btn btn-primary" data-action="submit">Submit</button>
            <button class="btn btn-primary" data-action="login" style="display:none">Sign in with GitHub</button>
          </div>
        </div>
      `;
      document.body.appendChild(popup);

      const position = () => {
        const rect = anchor.getBoundingClientRect();
        let left = rect.left;
        let top = rect.bottom + 10;
        const width = Math.min(460, window.innerWidth - 32);
        if (left + width > window.innerWidth - 8) left = Math.max(8, window.innerWidth - width - 8);
        if (top + 280 > window.innerHeight) top = Math.max(8, rect.top - 300);
        popup.style.left = `${Math.round(left)}px`;
        popup.style.top = `${Math.round(top)}px`;
      };
      position();
      // animate in
      requestAnimationFrame(() => popup.classList.add('is-visible'));

      // Auth gate: check if user is logged in
      const authWrap = popup.querySelector('.compose-actions-auth');
      const authNote = popup.querySelector('.compose-auth-status');
      const btnSubmit = popup.querySelector('[data-action="submit"]');
      const btnLogin = popup.querySelector('[data-action="login"]');
      const setAuth = (loggedIn) => {
        if (!authWrap) return;
        authWrap.setAttribute('data-auth', loggedIn ? 'yes' : 'no');
        if (authNote) authNote.textContent = loggedIn ? '' : 'Sign in to submit feedback.';
        if (btnSubmit) btnSubmit.style.display = loggedIn ? '' : 'none';
        if (btnLogin) btnLogin.style.display = loggedIn ? 'none' : '';
      };
      fetch('/api/auth/github/me').then((r) => setAuth(r.ok)).catch(() => setAuth(false));

      const textarea = popup.querySelector('textarea');
      if (preset && textarea) { try { textarea.value = preset; } catch {} }
      setTimeout(() => textarea && textarea.focus(), 50);

      const close = () => {
        popup.remove();
        // Remove temp highlight on cancel. If submission succeeded we already converted it.
        if (this.tempHighlight && this.tempHighlight.parentNode) {
          const frag = document.createDocumentFragment();
          while (this.tempHighlight.firstChild) frag.appendChild(this.tempHighlight.firstChild);
          this.tempHighlight.replaceWith(frag);
          this.tempHighlight = null;
        }
      };
      popup.querySelector('.compose-close')?.addEventListener('click', close);
      popup.querySelector('[data-action="cancel"]')?.addEventListener('click', close);

      // Login button: persist draft and redirect
      popup.querySelector('[data-action="login"]')?.addEventListener('click', () => {
        try {
          const ta = popup.querySelector('textarea');
          const draft = ta ? (ta['value'] || '') : '';
          sessionStorage.setItem('fz_feedback_draft', draft);
          sessionStorage.setItem('fz_feedback_quote', quote);
          const temp = document.querySelector('.feedback-highlight--temp');
          if (temp && typeof temp === 'object' && typeof (temp['getBoundingClientRect']) === 'function') {
            const r = temp['getBoundingClientRect']();
            const rect = { left: r.left, top: r.top, right: r.right, bottom: r.bottom };
            sessionStorage.setItem('fz_feedback_rect', JSON.stringify(rect));
          }
        } catch {}
        const state = (typeof getState === 'function' ? getState() : null) || { slug: location.pathname };
        const returnTo = encodeURIComponent(state.slug || location.pathname);
        location.href = `/api/auth/github/login?returnTo=${returnTo}`;
      });

      const onSubmit = async () => {
        const ta = popup.querySelector('textarea');
        const message = ta ? String(((ta && (ta)['value']) || '')).trim() : '';
        if (!message) {
          if (ta && typeof (ta)['focus'] === 'function') (ta)['focus']();
          return;
        }
        const state = (typeof getState === 'function' ? getState() : null) || { slug: null };
        const payload = {
          slug: state.slug || location.pathname,
          selection: { text: quote },
          message
        };
        try {
          const res = await fetch('/api/feedback', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
          if (res.status === 401) {
            // Switch UI to login mode if token missing/invalid
            if (authWrap) setAuth(false);
            return;
          }
          if (!res.ok) throw new Error(`Submit failed: ${res.status}`);
          // Remove temp highlight to avoid double-wrapping; refreshed data will add permanent one
          if (this.tempHighlight && this.tempHighlight.parentNode) {
            const frag = document.createDocumentFragment();
            while (this.tempHighlight.firstChild) frag.appendChild(this.tempHighlight.firstChild);
            this.tempHighlight.replaceWith(frag);
            this.tempHighlight = null;
          }
          popup.remove();
          // Optionally, signal others to refresh
          window.dispatchEvent(new CustomEvent('feedback:reload'));
        } catch (err) {
          console.error(err);
          // Simple error affordance
          const btn = popup.querySelector('[data-action="submit"]');
          if (btn) { btn.textContent = 'Retry'; }
        }
      };
      popup.querySelector('[data-action="submit"]')?.addEventListener('click', onSubmit);

      const onOutside = (evt) => {
        if (!popup.contains(evt.target)) {
          document.removeEventListener('mousedown', onOutside);
          close();
        }
      };
      setTimeout(() => document.addEventListener('mousedown', onOutside), 50);

      let ticking = false;
      const onScrollResize = () => {
        if (!ticking) { requestAnimationFrame(() => { position(); ticking = false; }); ticking = true; }
      };
      window.addEventListener('scroll', onScrollResize, { passive: true });
      window.addEventListener('resize', onScrollResize);
    }

    // Restore draft after OAuth login: re-anchor by matching the saved quote, else use last known rect
    restoreFromSession() {
      try {
        const quote = sessionStorage.getItem('fz_feedback_quote');
        const draft = sessionStorage.getItem('fz_feedback_draft');
        const rectStr = sessionStorage.getItem('fz_feedback_rect');
        if (!quote) return;
        let anchor = null;
        const loc = this.findTextInPage(quote);
        if (loc) {
          const span = document.createElement('span');
          span.className = 'feedback-highlight feedback-highlight--temp';
          const frag = loc.range.extractContents();
          span.appendChild(frag);
          loc.range.insertNode(span);
          anchor = span;
          this.tempHighlight = span;
        } else {
          const fallback = document.createElement('div');
          fallback.style.position = 'fixed';
          const rect = rectStr ? JSON.parse(rectStr) : null;
          const left = rect?.left ?? 16;
          const top = (rect?.bottom ?? 100);
          fallback.style.left = `${Math.round(left)}px`;
          fallback.style.top = `${Math.round(top)}px`;
          fallback.style.width = '1px';
          fallback.style.height = '1px';
          fallback.style.pointerEvents = 'none';
          document.body.appendChild(fallback);
          anchor = fallback;
        }
        try { if (anchor && typeof (anchor['scrollIntoView']) === 'function') { anchor['scrollIntoView']({ behavior: 'instant', block: 'center' }); } } catch {}
        setTimeout(() => this.showComposer({ quote, anchor, preset: draft || '' }), 60);
      } catch {}
      try { sessionStorage.removeItem('fz_feedback_quote'); } catch {}
      try { sessionStorage.removeItem('fz_feedback_draft'); } catch {}
      try { sessionStorage.removeItem('fz_feedback_rect'); } catch {}
    }

    findTextInPage(selectedText) {
      if (!selectedText) return null;
      const walker = document.createTreeWalker(document.body, NodeFilter.SHOW_TEXT, {
        acceptNode(node) {
          const parent = node.parentElement;
          if (!parent) return NodeFilter.FILTER_REJECT;
          const tag = parent.tagName;
          if (tag === 'SCRIPT' || tag === 'STYLE') return NodeFilter.FILTER_REJECT;
          return NodeFilter.FILTER_ACCEPT;
        },
      });
      let node;
      while ((node = walker.nextNode())) {
        const text = node.textContent || '';
        const index = text.indexOf(selectedText);
        if (index !== -1) {
          const range = document.createRange();
          range.setStart(node, index);
          range.setEnd(node, index + selectedText.length);
          return { range, element: node.parentElement, text: selectedText };
        }
      }
      return null;
    }

    escapeHtml(s) {
      return s.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
    }

    position(range) {
      const rect = range.getBoundingClientRect();
      const el = this.ensureEl();
      const padding = 8;
      const promptWidth = 160;
      const promptHeight = 34;

      let left = rect.right + padding;
      let top = rect.top - promptHeight - 4;

      if (left + promptWidth > window.innerWidth - 8) {
        left = Math.max(8, rect.left - promptWidth - padding);
      }
      if (top < 8) {
        top = Math.min(window.innerHeight - promptHeight - 8, rect.bottom + 6);
      }

      el.style.left = `${Math.round(left)}px`;
      el.style.top = `${Math.round(top)}px`;
    }

    show(range) {
      const el = this.ensureEl();
      this.position(range);
      el.style.display = 'flex';
      el.style.opacity = '1';
    }

    hide() {
      if (this.el) {
        this.el.style.display = 'none';
        this.el.style.opacity = '0';
      }
    }
  }

  const boot = () => {
    const ctrl = new SelectionPromptController();
    ctrl.restoreFromSession();
  };
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', boot, { once: true });
  } else {
    boot();
  }
</script>
