---
title: Stateful handlers
description: Modeling long-lived, stateful handlers with Fluxzero
slug: docs/guides/modeling-and-persistence/stateful-handlers
sidebar:
   order: 210
---

import { Tabs, TabItem } from '@astrojs/starlight/components';
import { Aside } from '@astrojs/starlight/components';

While aggregates represent domain entities, Fluxzero also supports long-lived **stateful handlers** for modeling workflows,
external interactions, or background processes that span multiple messages.

To declare a stateful handler, annotate a class with `@Stateful`:

<Tabs>
  <TabItem label="Java">
    ```java
    @Stateful
    public record PaymentProcess(@EntityId String paymentId,
                                 @Association String pspReference,
                                 PaymentStatus status) {

        @HandleEvent
        static PaymentProcess on(PaymentInitiated event) {
            String pspRef = Fluxzero.sendCommandAndWait(new ExecutePayment(...));
            return new PaymentProcess(event.getPaymentId(), pspRef, PaymentStatus.PENDING);
        }

        @HandleEvent
        PaymentProcess on(PaymentConfirmed event) {
            // pspReference property in PaymentConfirmed is matched
            return withStatus(PaymentStatus.CONFIRMED);
        }
    }
    ```
  </TabItem>
  <TabItem label="Kotlin">
    ```kotlin
    @Stateful
    data class PaymentProcess(
        @EntityId val paymentId: String,
        @Association val pspReference: String,
        val status: PaymentStatus
    ) {

        companion object {
            @HandleEvent
            fun on(event: PaymentInitiated): PaymentProcess {
                val pspRef = Fluxzero.sendCommandAndWait(ExecutePayment(...))
                return PaymentProcess(event.paymentId, pspRef, PaymentStatus.PENDING)
            }
        }

        @HandleEvent
        fun on(event: PaymentConfirmed): PaymentProcess {
            // pspReference property in PaymentConfirmed is matched
            return copy(status = PaymentStatus.CONFIRMED)
        }
    }
    ```
  </TabItem>
</Tabs>

## Key properties

- `@Stateful` classes persist their state using Fluxzero’s document store (or a custom `HandlerRepository`)
- They are automatically invoked when messages match their associations (`@Association` fields or methods)
- Matching is dynamic and supports multiple handler instances per message
- Multiple handler methods can exist for different message types
- Handlers are immutable by convention — they are updated by returning a new version of themselves
- Returning `null` deletes the handler (useful for terminating flows)

<Aside type="note">
Like other handlers, stateful handlers may be annotated with `@Consumer` for tracking isolation.
</Aside>

<Tabs>
  <TabItem label="Java">
    ```java
    @HandleEvent
    PaymentProcess on(PaymentFailed event) {
        return null; // remove from store
    }
    ```
  </TabItem>
  <TabItem label="Kotlin">
    ```kotlin
    @HandleEvent
    fun on(event: PaymentFailed): PaymentProcess? {
        return null // remove from store
    }
    ```
  </TabItem>
</Tabs>

## Matching via association

Handlers are selected based on one or more `@Association` fields. When a message with a matching association is
published, the handler is loaded and invoked.

<Tabs>
  <TabItem label="Java">
    ```java
    @Association
    String pspReference;
    ```
  </TabItem>
  <TabItem label="Kotlin">
    ```kotlin
    @Association
    val pspReference: String
    ```
  </TabItem>
</Tabs>

<Aside type="note">
This is similar to correlation IDs or saga keys — but built-in and fully indexed.
</Aside>

## State update semantics

- If the handler method returns a new instance of its class, it replaces the previous version in the store
- If it returns `void` or a value of another type, state is left unchanged
- This allows safe utility returns (like `Duration` for `@HandleSchedule`)

<Tabs>
  <TabItem label="Java">
    ```java
    @HandleSchedule
    Duration on(CheckStatus schedule) {
        // Return next delay (but don’t update handler state)
        return Duration.ofMinutes(5);
    }
    ```
  </TabItem>
  <TabItem label="Kotlin">
    ```kotlin
    @HandleSchedule
    fun on(schedule: CheckStatus): Duration {
        // Return next delay (but don’t update handler state)
        return Duration.ofMinutes(5)
    }
    ```
  </TabItem>
</Tabs>

## Batch commit control

By default, changes to a `@Stateful` handler are persisted immediately. Set `commitInBatch = true` to defer updates
until the current message batch completes. Fluxzero ensures that:

- Newly created handlers are matched by subsequent messages
- Deleted handlers won’t receive more messages in the batch
- Updates are consistent within the batch

<Aside type="note">
This dramatically improves performance for high-throughput workflows.
</Aside>

## Indexing support

Stateful handlers are automatically `@Searchable`. You can configure:

- A custom collection name
- Time-based indexing fields (e.g. `timestampPath` or `endPath`)

This allows you to query, filter, and monitor stateful handlers using Fluxzero’s search API — covered in the next section.

---

Stateful handlers are ideal for:

- **Workflows** and **sagas**
- **Pollers**, **reminders**, and **background jobs**
- External **API orchestrations**
- **Process managers** (e.g., order fulfillment, payment retry, etc.)

They complement aggregates without competing with them — and allow modeling temporal behavior in a clean, event-driven way.